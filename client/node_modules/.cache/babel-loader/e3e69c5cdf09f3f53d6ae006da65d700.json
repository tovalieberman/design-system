{"ast":null,"code":"'use strict'; // Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.  The trailing byte in the\n// section will always be 0x20, or in some implementations 0x00.\n// this module encodes and decodes these things.\n\nvar encode = exports.encode = function (num, buf) {\n  buf[buf.length - 1] = 0x20;\n  if (num < 0) encodeNegative(num, buf);else encodePositive(num, buf);\n  return buf;\n};\n\nvar encodePositive = function encodePositive(num, buf) {\n  buf[0] = 0x80;\n\n  for (var i = buf.length - 2; i > 0; i--) {\n    if (num === 0) buf[i] = 0;else {\n      buf[i] = num % 0x100;\n      num = Math.floor(num / 0x100);\n    }\n  }\n};\n\nvar encodeNegative = function encodeNegative(num, buf) {\n  buf[0] = 0xff;\n  var flipped = false;\n  num = num * -1;\n\n  for (var i = buf.length - 2; i > 0; i--) {\n    var byte;\n    if (num === 0) byte = 0;else {\n      byte = num % 0x100;\n      num = Math.floor(num / 0x100);\n    }\n    if (flipped) buf[i] = onesComp(byte);else if (byte === 0) buf[i] = 0;else {\n      flipped = true;\n      buf[i] = twosComp(byte);\n    }\n  }\n};\n\nvar parse = exports.parse = function (buf) {\n  var post = buf[buf.length - 1];\n  var pre = buf[0];\n  return pre === 0x80 ? pos(buf.slice(1, buf.length - 1)) : twos(buf.slice(1, buf.length - 1));\n};\n\nvar twos = function twos(buf) {\n  var len = buf.length;\n  var sum = 0;\n  var flipped = false;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    var f;\n    if (flipped) f = onesComp(byte);else if (byte === 0) f = byte;else {\n      flipped = true;\n      f = twosComp(byte);\n    }\n    if (f !== 0) sum += f * Math.pow(256, len - i - 1);\n  }\n\n  return sum * -1;\n};\n\nvar pos = function pos(buf) {\n  var len = buf.length;\n  var sum = 0;\n\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i];\n    if (byte !== 0) sum += byte * Math.pow(256, len - i - 1);\n  }\n\n  return sum;\n};\n\nvar onesComp = function onesComp(byte) {\n  return (0xff ^ byte) & 0xff;\n};\n\nvar twosComp = function twosComp(byte) {\n  return (0xff ^ byte) + 1 & 0xff;\n};","map":null,"metadata":{},"sourceType":"script"}