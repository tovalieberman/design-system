{"ast":null,"code":"// @ts-check\n\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n\n/** @typedef {import(\"webpack/lib/Chunk.js\")} WebpackChunk */\n'use strict';\n/**\n * @file\n * This file uses webpack to compile a template with a child compiler.\n *\n * [TEMPLATE] -> [JAVASCRIPT]\n *\n */\n\n'use strict';\n\nvar _classCallCheck = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar NodeTemplatePlugin = require('webpack/lib/node/NodeTemplatePlugin');\n\nvar NodeTargetPlugin = require('webpack/lib/node/NodeTargetPlugin');\n\nvar LoaderTargetPlugin = require('webpack/lib/LoaderTargetPlugin');\n\nvar LibraryTemplatePlugin = require('webpack/lib/LibraryTemplatePlugin');\n\nvar SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');\n/**\n * The HtmlWebpackChildCompiler is a helper to allow resusing one childCompiler\n * for multile HtmlWebpackPlugin instances to improve the compilation performance.\n */\n\n\nvar HtmlWebpackChildCompiler =\n/*#__PURE__*/\nfunction () {\n  function HtmlWebpackChildCompiler() {\n    _classCallCheck(this, HtmlWebpackChildCompiler);\n\n    /**\n     * @type {string[]} templateIds\n     * The template array will allow us to keep track which input generated which output\n     */\n    this.templates = [];\n    /**\n     * @type {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}\n     */\n\n    this.compilationPromise; // eslint-disable-line\n\n    /**\n     * @type {number}\n     */\n\n    this.compilationStartedTimestamp; // eslint-disable-line\n\n    /**\n     * @type {number}\n     */\n\n    this.compilationEndedTimestamp; // eslint-disable-line\n\n    /**\n     * All file dependencies of the child compiler\n     * @type {string[]}\n     */\n\n    this.fileDependencies = [];\n  }\n  /**\n   * Add a templatePath to the child compiler\n   * The given template will be compiled by `compileTemplates`\n   * @param {string} template - The webpack path to the template e.g. `'!!html-loader!index.html'`\n   * @returns {boolean} true if the template is new\n   */\n\n\n  _createClass(HtmlWebpackChildCompiler, [{\n    key: \"addTemplate\",\n    value: function addTemplate(template) {\n      var templateId = this.templates.indexOf(template); // Don't add the template to the compiler if a similar template was already added\n\n      if (templateId !== -1) {\n        return false;\n      } // A child compiler can compile only once\n      // throw an error if a new template is added after the compilation started\n\n\n      if (this.isCompiling()) {\n        throw new Error('New templates can only be added before `compileTemplates` was called.');\n      } // Add the template to the childCompiler\n\n\n      this.templates.push(template); // Mark the cache invalid\n\n      return true;\n    }\n    /**\n     * Returns true if the childCompiler is currently compiling\n     * @retuns {boolean}\n     */\n\n  }, {\n    key: \"isCompiling\",\n    value: function isCompiling() {\n      return !this.didCompile() && this.compilationStartedTimestamp !== undefined;\n    }\n    /**\n     * Returns true if the childCOmpiler is done compiling\n     */\n\n  }, {\n    key: \"didCompile\",\n    value: function didCompile() {\n      return this.compilationEndedTimestamp !== undefined;\n    }\n    /**\n     * This function will start the template compilation\n     * once it is started no more templates can be added\n     *\n     * @param {WebpackCompilation} mainCompilation\n     * @returns {Promise<{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}>}\n     */\n\n  }, {\n    key: \"compileTemplates\",\n    value: function compileTemplates(mainCompilation) {\n      var _this = this;\n\n      // To prevent multiple compilations for the same template\n      // the compilation is cached in a promise.\n      // If it already exists return\n      if (this.compilationPromise) {\n        return this.compilationPromise;\n      } // The entry file is just an empty helper as the dynamic template\n      // require is added in \"loader.js\"\n\n\n      var outputOptions = {\n        filename: '__child-[name]',\n        publicPath: mainCompilation.outputOptions.publicPath\n      };\n      var compilerName = 'HtmlWebpackCompiler'; // Create an additional child compiler which takes the template\n      // and turns it into an Node.JS html factory.\n      // This allows us to use loaders during the compilation\n\n      var childCompiler = mainCompilation.createChildCompiler(compilerName, outputOptions); // The file path context which webpack uses to resolve all relative files to\n\n      childCompiler.context = mainCompilation.compiler.context; // Compile the template to nodejs javascript\n\n      new NodeTemplatePlugin(outputOptions).apply(childCompiler);\n      new NodeTargetPlugin().apply(childCompiler);\n      new LibraryTemplatePlugin('HTML_WEBPACK_PLUGIN_RESULT', 'var').apply(childCompiler);\n      new LoaderTargetPlugin('node').apply(childCompiler); // Add all templates\n\n      this.templates.forEach(function (template, index) {\n        new SingleEntryPlugin(childCompiler.context, template, \"HtmlWebpackPlugin_\".concat(index)).apply(childCompiler);\n      });\n      this.compilationStartedTimestamp = new Date().getTime();\n      this.compilationPromise = new Promise(function (resolve, reject) {\n        childCompiler.runAsChild(function (err, entries, childCompilation) {\n          // Extract templates\n          var compiledTemplates = entries ? extractHelperFilesFromCompilation(mainCompilation, childCompilation, outputOptions.filename, entries) : []; // Extract file dependencies\n\n          if (entries) {\n            _this.fileDependencies = Array.from(childCompilation.fileDependencies);\n          } // Reject the promise if the childCompilation contains error\n\n\n          if (childCompilation && childCompilation.errors && childCompilation.errors.length) {\n            var errorDetails = childCompilation.errors.map(function (error) {\n              return error.message + (error.error ? ':\\n' + error.error : '');\n            }).join('\\n');\n            reject(new Error('Child compilation failed:\\n' + errorDetails));\n            return;\n          } // Reject if the error object contains errors\n\n\n          if (err) {\n            reject(err);\n            return;\n          }\n          /**\n           * @type {{[templatePath: string]: { content: string, hash: string, entry: WebpackChunk }}}\n           */\n\n\n          var result = {};\n          compiledTemplates.forEach(function (templateSource, entryIndex) {\n            // The compiledTemplates are generated from the entries added in\n            // the addTemplate function.\n            // Therefore the array index of this.templates should be the as entryIndex.\n            result[_this.templates[entryIndex]] = {\n              content: templateSource,\n              hash: childCompilation.hash,\n              entry: entries[entryIndex]\n            };\n          });\n          _this.compilationEndedTimestamp = new Date().getTime();\n          resolve(result);\n        });\n      });\n      return this.compilationPromise;\n    }\n  }]);\n\n  return HtmlWebpackChildCompiler;\n}();\n/**\n * The webpack child compilation will create files as a side effect.\n * This function will extract them and clean them up so they won't be written to disk.\n *\n * Returns the source code of the compiled templates as string\n *\n * @returns Array<string>\n */\n\n\nfunction extractHelperFilesFromCompilation(mainCompilation, childCompilation, filename, childEntryChunks) {\n  var helperAssetNames = childEntryChunks.map(function (entryChunk, index) {\n    return mainCompilation.mainTemplate.hooks.assetPath.call(filename, {\n      hash: childCompilation.hash,\n      chunk: entryChunk,\n      name: \"HtmlWebpackPlugin_\".concat(index)\n    });\n  });\n  helperAssetNames.forEach(function (helperFileName) {\n    delete mainCompilation.assets[helperFileName];\n  });\n  var helperContents = helperAssetNames.map(function (helperFileName) {\n    return childCompilation.assets[helperFileName].source();\n  });\n  return helperContents;\n}\n/**\n * @type {WeakMap<WebpackCompiler, HtmlWebpackChildCompiler>}}\n */\n\n\nvar childCompilerCache = new WeakMap();\n/**\n * Get child compiler from cache or a new child compiler for the given mainCompilation\n *\n * @param {WebpackCompiler} mainCompiler\n */\n\nfunction getChildCompiler(mainCompiler) {\n  var cachedChildCompiler = childCompilerCache.get(mainCompiler);\n\n  if (cachedChildCompiler) {\n    return cachedChildCompiler;\n  }\n\n  var newCompiler = new HtmlWebpackChildCompiler();\n  childCompilerCache.set(mainCompiler, newCompiler);\n  return newCompiler;\n}\n/**\n * Remove the childCompiler from the cache\n *\n * @param {WebpackCompiler} mainCompiler\n */\n\n\nfunction clearCache(mainCompiler) {\n  var childCompiler = getChildCompiler(mainCompiler); // If this childCompiler was already used\n  // remove the entire childCompiler from the cache\n\n  if (childCompiler.isCompiling() || childCompiler.didCompile()) {\n    childCompilerCache.delete(mainCompiler);\n  }\n}\n/**\n * Register a template for the current main compiler\n * @param {WebpackCompiler} mainCompiler\n * @param {string} templatePath\n */\n\n\nfunction addTemplateToCompiler(mainCompiler, templatePath) {\n  var childCompiler = getChildCompiler(mainCompiler);\n  var isNew = childCompiler.addTemplate(templatePath);\n\n  if (isNew) {\n    clearCache(mainCompiler);\n  }\n}\n/**\n * Starts the compilation for all templates.\n * This has to be called once all templates where added.\n *\n * If this function is called multiple times it will use a cache inside\n * the childCompiler\n *\n * @param {string} templatePath\n * @param {string} outputFilename\n * @param {WebpackCompilation} mainCompilation\n */\n\n\nfunction compileTemplate(templatePath, outputFilename, mainCompilation) {\n  var childCompiler = getChildCompiler(mainCompilation.compiler);\n  return childCompiler.compileTemplates(mainCompilation).then(function (compiledTemplates) {\n    if (!compiledTemplates[templatePath]) console.log(Object.keys(compiledTemplates), templatePath);\n    var compiledTemplate = compiledTemplates[templatePath]; // Replace [hash] placeholders in filename\n\n    var outputName = mainCompilation.mainTemplate.hooks.assetPath.call(outputFilename, {\n      hash: compiledTemplate.hash,\n      chunk: compiledTemplate.entry\n    });\n    return {\n      // Hash of the template entry point\n      hash: compiledTemplate.hash,\n      // Output name\n      outputName: outputName,\n      // Compiled code\n      content: compiledTemplate.content\n    };\n  });\n}\n/**\n * Return all file dependencies of the last child compilation\n *\n * @param {WebpackCompiler} compiler\n * @returns {Array<string>}\n */\n\n\nfunction getFileDependencies(compiler) {\n  var childCompiler = getChildCompiler(compiler);\n  return childCompiler.fileDependencies;\n}\n/**\n * @type {WeakMap<WebpackCompilation, WeakMap<HtmlWebpackChildCompiler, boolean>>}}\n */\n\n\nvar hasOutdatedCompilationDependenciesMap = new WeakMap();\n/**\n * Returns `true` if the file dependencies of the current childCompiler\n * for the given mainCompilation are outdated.\n *\n * Uses the `hasOutdatedCompilationDependenciesMap` cache if possible.\n *\n * @param {WebpackCompilation} mainCompilation\n * @returns {boolean}\n */\n\nfunction hasOutDatedTemplateCache(mainCompilation) {\n  var childCompiler = getChildCompiler(mainCompilation.compiler);\n  /**\n   * @type {WeakMap<HtmlWebpackChildCompiler, boolean>|undefined}\n   */\n\n  var hasOutdatedChildCompilerDependenciesMap = hasOutdatedCompilationDependenciesMap.get(mainCompilation); // Create map for childCompiler if none exist\n\n  if (!hasOutdatedChildCompilerDependenciesMap) {\n    hasOutdatedChildCompilerDependenciesMap = new WeakMap();\n    hasOutdatedCompilationDependenciesMap.set(mainCompilation, hasOutdatedChildCompilerDependenciesMap);\n  } // Try to get the `checkChildCompilerCache` result from cache\n\n\n  var isOutdated = hasOutdatedChildCompilerDependenciesMap.get(childCompiler);\n\n  if (isOutdated !== undefined) {\n    return isOutdated;\n  } // If `checkChildCompilerCache` has never been called for the given\n  // `mainCompilation` and `childCompiler` combination call it:\n\n\n  isOutdated = isChildCompilerCacheOutdated(mainCompilation, childCompiler);\n  hasOutdatedChildCompilerDependenciesMap.set(childCompiler, isOutdated);\n  return isOutdated;\n}\n/**\n * Returns `true` if the file dependencies of the given childCompiler are outdated.\n *\n * @param {WebpackCompilation} mainCompilation\n * @param {HtmlWebpackChildCompiler} childCompiler\n * @returns {boolean}\n */\n\n\nfunction isChildCompilerCacheOutdated(mainCompilation, childCompiler) {\n  // If the compilation was never run there is no invalid cache\n  if (!childCompiler.compilationStartedTimestamp) {\n    return false;\n  } // Check if any dependent file was changed after the last compilation\n\n\n  var fileTimestamps = mainCompilation.fileTimestamps;\n  var isCacheOutOfDate = childCompiler.fileDependencies.some(function (fileDependency) {\n    var timestamp = fileTimestamps.get(fileDependency); // If the timestamp is not known the file is new\n    // If the timestamp is larger then the file has changed\n    // Otherwise the file is still the same\n\n    return !timestamp || timestamp > childCompiler.compilationStartedTimestamp;\n  });\n  return isCacheOutOfDate;\n}\n\nmodule.exports = {\n  addTemplateToCompiler: addTemplateToCompiler,\n  compileTemplate: compileTemplate,\n  hasOutDatedTemplateCache: hasOutDatedTemplateCache,\n  clearCache: clearCache,\n  getFileDependencies: getFileDependencies\n};","map":null,"metadata":{},"sourceType":"script"}