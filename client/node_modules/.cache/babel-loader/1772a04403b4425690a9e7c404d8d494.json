{"ast":null,"code":"// @ts-check\n// Import types\n\n/* eslint-disable */\n/// <reference path=\"./typings.d.ts\" />\n\n/* eslint-enable */\n\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n'use strict'; // use Polyfill for util.promisify in node versions < v8\n\nvar _slicedToArray = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar promisify = require('util.promisify');\n\nvar vm = require('vm');\n\nvar fs = require('fs');\n\nvar _ = require('lodash');\n\nvar path = require('path');\n\nvar loaderUtils = require('loader-utils');\n\nvar _require = require('./lib/html-tags'),\n    createHtmlTagObject = _require.createHtmlTagObject,\n    htmlTagObjectToString = _require.htmlTagObjectToString;\n\nvar childCompiler = require('./lib/compiler.js');\n\nvar prettyError = require('./lib/errors.js');\n\nvar chunkSorter = require('./lib/chunksorter.js');\n\nvar getHtmlWebpackPluginHooks = require('./lib/hooks.js').getHtmlWebpackPluginHooks;\n\nvar fsStatAsync = promisify(fs.stat);\nvar fsReadFileAsync = promisify(fs.readFile);\n\nvar HtmlWebpackPlugin =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Partial<HtmlWebpackPluginOptions>} [options]\n   */\n  function HtmlWebpackPlugin(options) {\n    _classCallCheck(this, HtmlWebpackPlugin);\n\n    /** @type {Partial<HtmlWebpackPluginOptions>} */\n    var userOptions = options || {}; // Default options\n\n    /** @type {HtmlWebpackPluginOptions} */\n\n    var defaultOptions = {\n      template: path.join(__dirname, 'default_index.ejs'),\n      templateContent: false,\n      templateParameters: templateParametersGenerator,\n      filename: 'index.html',\n      hash: false,\n      inject: true,\n      compile: true,\n      favicon: false,\n      minify: undefined,\n      cache: true,\n      showErrors: true,\n      chunks: 'all',\n      excludeChunks: [],\n      chunksSortMode: 'auto',\n      meta: {},\n      title: 'Webpack App',\n      xhtml: false\n    };\n    /** @type {HtmlWebpackPluginOptions} */\n\n    this.options = Object.assign(defaultOptions, userOptions); // Default metaOptions if no template is provided\n\n    if (!userOptions.template && this.options.templateContent === false && this.options.meta) {\n      var defaultMeta = {\n        // From https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag\n        viewport: 'width=device-width, initial-scale=1'\n      };\n      this.options.meta = Object.assign({}, this.options.meta, defaultMeta, userOptions.meta);\n    } // Instance variables to keep caching information\n    // for multiple builds\n\n\n    this.childCompilerHash = undefined;\n    /**\n     * @type {string | undefined}\n     */\n\n    this.childCompilationOutputName = undefined;\n    this.assetJson = undefined;\n    this.hash = undefined;\n    this.version = HtmlWebpackPlugin.version;\n  }\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n\n\n  _createClass(HtmlWebpackPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      var self = this;\n      var isCompilationCached = false;\n      /** @type Promise<string> */\n\n      var compilationPromise;\n      this.options.template = this.getFullTemplatePath(this.options.template, compiler.context); // convert absolute filename into relative so that webpack can\n      // generate it at correct location\n\n      var filename = this.options.filename;\n\n      if (path.resolve(filename) === path.normalize(filename)) {\n        this.options.filename = path.relative(compiler.options.output.path, filename);\n      } // `contenthash` is introduced in webpack v4.3\n      // which conflicts with the plugin's existing `contenthash` method,\n      // hence it is renamed to `templatehash` to avoid conflicts\n\n\n      this.options.filename = this.options.filename.replace(/\\[(?:(\\w+):)?contenthash(?::([a-z]+\\d*))?(?::(\\d+))?\\]/ig, function (match) {\n        return match.replace('contenthash', 'templatehash');\n      }); // Check if webpack is running in production mode\n      // @see https://github.com/webpack/webpack/blob/3366421f1784c449f415cda5930a8e445086f688/lib/WebpackOptionsDefaulter.js#L12-L14\n\n      var isProductionLikeMode = compiler.options.mode === 'production' || !compiler.options.mode;\n      var minify = this.options.minify;\n\n      if (minify === true || minify === undefined && isProductionLikeMode) {\n        this.options.minify = {\n          // https://github.com/kangax/html-minifier#options-quick-reference\n          collapseWhitespace: true,\n          removeComments: true,\n          removeRedundantAttributes: true,\n          removeScriptTypeAttributes: true,\n          removeStyleLinkTypeAttributes: true,\n          useShortDoctype: true\n        };\n      } // Clear the cache once a new HtmlWebpackPlugin is added\n\n\n      childCompiler.clearCache(compiler); // Register all HtmlWebpackPlugins instances at the child compiler\n\n      compiler.hooks.thisCompilation.tap('HtmlWebpackPlugin', function (compilation) {\n        // Clear the cache if the child compiler is outdated\n        if (childCompiler.hasOutDatedTemplateCache(compilation)) {\n          childCompiler.clearCache(compiler);\n        } // Add this instances template to the child compiler\n\n\n        childCompiler.addTemplateToCompiler(compiler, _this.options.template); // Add file dependencies of child compiler to parent compiler\n        // to keep them watched even if we get the result from the cache\n\n        compilation.hooks.additionalChunkAssets.tap('HtmlWebpackPlugin', function () {\n          var childCompilerDependencies = childCompiler.getFileDependencies(compiler);\n          childCompilerDependencies.forEach(function (fileDependency) {\n            compilation.compilationDependencies.add(fileDependency);\n          });\n        });\n      });\n      compiler.hooks.make.tapAsync('HtmlWebpackPlugin', function (compilation, callback) {\n        // Compile the template (queued)\n        compilationPromise = childCompiler.compileTemplate(self.options.template, self.options.filename, compilation).catch(function (err) {\n          compilation.errors.push(prettyError(err, compiler.context).toString());\n          return {\n            content: self.options.showErrors ? prettyError(err, compiler.context).toJsonHtml() : 'ERROR',\n            outputName: self.options.filename,\n            hash: ''\n          };\n        }).then(function (compilationResult) {\n          // If the compilation change didnt change the cache is valid\n          isCompilationCached = Boolean(compilationResult.hash) && self.childCompilerHash === compilationResult.hash;\n          self.childCompilerHash = compilationResult.hash;\n          self.childCompilationOutputName = compilationResult.outputName;\n          callback();\n          return compilationResult.content;\n        });\n      });\n      compiler.hooks.emit.tapAsync('HtmlWebpackPlugin',\n      /**\n       * Hook into the webpack emit phase\n       * @param {WebpackCompilation} compilation\n       * @param {() => void} callback\n      */\n      function (compilation, callback) {\n        // Get all entry point names for this html file\n        var entryNames = Array.from(compilation.entrypoints.keys());\n        var filteredEntryNames = self.filterChunks(entryNames, self.options.chunks, self.options.excludeChunks);\n        var sortedEntryNames = self.sortEntryChunks(filteredEntryNames, _this.options.chunksSortMode, compilation);\n        var childCompilationOutputName = self.childCompilationOutputName;\n\n        if (childCompilationOutputName === undefined) {\n          throw new Error('Did not receive child compilation result');\n        } // Turn the entry point names into file paths\n\n\n        var assets = self.htmlWebpackPluginAssets(compilation, childCompilationOutputName, sortedEntryNames); // If this is a hot update compilation, move on!\n        // This solves a problem where an `index.html` file is generated for hot-update js files\n        // It only happens in Webpack 2, where hot updates are emitted separately before the full bundle\n\n        if (self.isHotUpdateCompilation(assets)) {\n          return callback();\n        } // If the template and the assets did not change we don't have to emit the html\n\n\n        var assetJson = JSON.stringify(self.getAssetFiles(assets));\n\n        if (isCompilationCached && self.options.cache && assetJson === self.assetJson) {\n          return callback();\n        } else {\n          self.assetJson = assetJson;\n        } // The html-webpack plugin uses a object representation for the html-tags which will be injected\n        // to allow altering them more easily\n        // Just before they are converted a third-party-plugin author might change the order and content\n\n\n        var assetsPromise = _this.getFaviconPublicPath(_this.options.favicon, compilation, assets.publicPath).then(function (faviconPath) {\n          assets.favicon = faviconPath;\n          return getHtmlWebpackPluginHooks(compilation).beforeAssetTagGeneration.promise({\n            assets: assets,\n            outputName: childCompilationOutputName,\n            plugin: self\n          });\n        }); // Turn the js and css paths into grouped HtmlTagObjects\n\n\n        var assetTagGroupsPromise = assetsPromise // And allow third-party-plugin authors to reorder and change the assetTags before they are grouped\n        .then(function (_ref) {\n          var assets = _ref.assets;\n          return getHtmlWebpackPluginHooks(compilation).alterAssetTags.promise({\n            assetTags: {\n              scripts: self.generatedScriptTags(assets.js),\n              styles: self.generateStyleTags(assets.css),\n              meta: [].concat(_toConsumableArray(self.generatedMetaTags(self.options.meta)), _toConsumableArray(self.generateFaviconTags(assets.favicon)))\n            },\n            outputName: childCompilationOutputName,\n            plugin: self\n          });\n        }).then(function (_ref2) {\n          var assetTags = _ref2.assetTags;\n          // Inject scripts to body unless it set explictly to head\n          var scriptTarget = self.options.inject === 'head' ? 'head' : 'body'; // Group assets to `head` and `body` tag arrays\n\n          var assetGroups = _this.generateAssetGroups(assetTags, scriptTarget); // Allow third-party-plugin authors to reorder and change the assetTags once they are grouped\n\n\n          return getHtmlWebpackPluginHooks(compilation).alterAssetTagGroups.promise({\n            headTags: assetGroups.headTags,\n            bodyTags: assetGroups.bodyTags,\n            outputName: childCompilationOutputName,\n            plugin: self\n          });\n        }); // Turn the compiled tempalte into a nodejs function or into a nodejs string\n\n        var templateEvaluationPromise = compilationPromise.then(function (compiledTemplate) {\n          // Allow to use a custom function / string instead\n          if (self.options.templateContent !== false) {\n            return self.options.templateContent;\n          } // Once everything is compiled evaluate the html factory\n          // and replace it with its content\n\n\n          return self.evaluateCompilationResult(compilation, compiledTemplate);\n        });\n        var templateExectutionPromise = Promise.all([assetsPromise, assetTagGroupsPromise, templateEvaluationPromise]) // Execute the template\n        .then(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 3),\n              assetsHookResult = _ref4[0],\n              assetTags = _ref4[1],\n              compilationResult = _ref4[2];\n\n          return typeof compilationResult !== 'function' ? compilationResult : self.executeTemplate(compilationResult, assetsHookResult.assets, {\n            headTags: assetTags.headTags,\n            bodyTags: assetTags.bodyTags\n          }, compilation);\n        });\n        var injectedHtmlPromise = Promise.all([assetTagGroupsPromise, templateExectutionPromise]) // Allow plugins to change the html before assets are injected\n        .then(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n              assetTags = _ref6[0],\n              html = _ref6[1];\n\n          var pluginArgs = {\n            html: html,\n            headTags: assetTags.headTags,\n            bodyTags: assetTags.bodyTags,\n            plugin: self,\n            outputName: childCompilationOutputName\n          };\n          return getHtmlWebpackPluginHooks(compilation).afterTemplateExecution.promise(pluginArgs);\n        }).then(function (_ref7) {\n          var html = _ref7.html,\n              headTags = _ref7.headTags,\n              bodyTags = _ref7.bodyTags;\n          return self.postProcessHtml(html, assets, {\n            headTags: headTags,\n            bodyTags: bodyTags\n          });\n        });\n        var emitHtmlPromise = injectedHtmlPromise // Allow plugins to change the html after assets are injected\n        .then(function (html) {\n          var pluginArgs = {\n            html: html,\n            plugin: self,\n            outputName: childCompilationOutputName\n          };\n          return getHtmlWebpackPluginHooks(compilation).beforeEmit.promise(pluginArgs).then(function (result) {\n            return result.html;\n          });\n        }).catch(function (err) {\n          // In case anything went wrong the promise is resolved\n          // with the error message and an error is logged\n          compilation.errors.push(prettyError(err, compiler.context).toString()); // Prevent caching\n\n          self.hash = null;\n          return self.options.showErrors ? prettyError(err, compiler.context).toHtml() : 'ERROR';\n        }).then(function (html) {\n          // Allow to use [templatehash] as placeholder for the html-webpack-plugin name\n          // See also https://survivejs.com/webpack/optimizing/adding-hashes-to-filenames/\n          // From https://github.com/webpack-contrib/extract-text-webpack-plugin/blob/8de6558e33487e7606e7cd7cb2adc2cccafef272/src/index.js#L212-L214\n          var finalOutputName = childCompilationOutputName.replace(/\\[(?:(\\w+):)?templatehash(?::([a-z]+\\d*))?(?::(\\d+))?\\]/ig, function (_, hashType, digestType, maxLength) {\n            return loaderUtils.getHashDigest(Buffer.from(html, 'utf8'), hashType, digestType, parseInt(maxLength, 10));\n          }); // Add the evaluated html code to the webpack assets\n\n          compilation.assets[finalOutputName] = {\n            source: function source() {\n              return html;\n            },\n            size: function size() {\n              return html.length;\n            }\n          };\n          return finalOutputName;\n        }).then(function (finalOutputName) {\n          return getHtmlWebpackPluginHooks(compilation).afterEmit.promise({\n            outputName: finalOutputName,\n            plugin: self\n          }).catch(function (err) {\n            console.error(err);\n            return null;\n          }).then(function () {\n            return null;\n          });\n        }); // Once all files are added to the webpack compilation\n        // let the webpack compiler continue\n\n        emitHtmlPromise.then(function () {\n          callback();\n        });\n      });\n    }\n    /**\n     * Evaluates the child compilation result\n     * @param {WebpackCompilation} compilation\n     * @param {string} source\n     * @returns {Promise<string | (() => string | Promise<string>)>}\n     */\n\n  }, {\n    key: \"evaluateCompilationResult\",\n    value: function evaluateCompilationResult(compilation, source) {\n      if (!source) {\n        return Promise.reject(new Error('The child compilation didn\\'t provide a result'));\n      } // The LibraryTemplatePlugin stores the template result in a local variable.\n      // To extract the result during the evaluation this part has to be removed.\n\n\n      source = source.replace('var HTML_WEBPACK_PLUGIN_RESULT =', '');\n      var template = this.options.template.replace(/^.+!/, '').replace(/\\?.+$/, '');\n      var vmContext = vm.createContext(_.extend({\n        HTML_WEBPACK_PLUGIN: true,\n        require: require\n      }, global));\n      var vmScript = new vm.Script(source, {\n        filename: template\n      }); // Evaluate code and cast to string\n\n      var newSource;\n\n      try {\n        newSource = vmScript.runInContext(vmContext);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      if (typeof newSource === 'object' && newSource.__esModule && newSource.default) {\n        newSource = newSource.default;\n      }\n\n      return typeof newSource === 'string' || typeof newSource === 'function' ? Promise.resolve(newSource) : Promise.reject(new Error('The loader \"' + this.options.template + '\" didn\\'t return html.'));\n    }\n    /**\n     * Generate the template parameters for the template function\n     * @param {WebpackCompilation} compilation\n     * @param {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * @returns {Promise<{[key: any]: any}>}\n     */\n\n  }, {\n    key: \"getTemplateParameters\",\n    value: function getTemplateParameters(compilation, assets, assetTags) {\n      var _this2 = this;\n\n      var templateParameters = this.options.templateParameters;\n\n      if (templateParameters === false) {\n        return Promise.resolve({});\n      }\n\n      if (typeof templateParameters === 'function') {\n        return Promise.resolve().then(function () {\n          return templateParameters(compilation, assets, assetTags, _this2.options);\n        });\n      }\n\n      if (typeof templateParameters === 'object') {\n        return Promise.resolve(templateParameters);\n      }\n\n      throw new Error('templateParameters has to be either a function or an object');\n    }\n    /**\n     * This function renders the actual html by executing the template function\n     *\n     * @param {(templatePArameters) => string | Promise<string>} templateFunction\n     * @param {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * @param {WebpackCompilation} compilation\n     *\n     * @returns Promise<string>\n     */\n\n  }, {\n    key: \"executeTemplate\",\n    value: function executeTemplate(templateFunction, assets, assetTags, compilation) {\n      // Template processing\n      var templateParamsPromise = this.getTemplateParameters(compilation, assets, assetTags);\n      return templateParamsPromise.then(function (templateParams) {\n        try {\n          // If html is a promise return the promise\n          // If html is a string turn it into a promise\n          return templateFunction(templateParams);\n        } catch (e) {\n          compilation.errors.push(new Error('Template execution failed: ' + e));\n          return Promise.reject(e);\n        }\n      });\n    }\n    /**\n     * Html Post processing\n     *\n     * @param {any} html\n     * The input html\n     * @param {any} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * The asset tags to inject\n     *\n     * @returns {Promise<string>}\n     */\n\n  }, {\n    key: \"postProcessHtml\",\n    value: function postProcessHtml(html, assets, assetTags) {\n      if (typeof html !== 'string') {\n        return Promise.reject(new Error('Expected html to be a string but got ' + JSON.stringify(html)));\n      }\n\n      var htmlAfterInjection = this.options.inject ? this.injectAssetsIntoHtml(html, assets, assetTags) : html;\n      var htmlAfterMinification = this.options.minify ? require('html-minifier').minify(htmlAfterInjection, this.options.minify) : htmlAfterInjection;\n      return Promise.resolve(htmlAfterMinification);\n    }\n    /*\n     * Pushes the content of the given filename to the compilation assets\n     * @param {string} filename\n     * @param {WebpackCompilation} compilation\n     *\n     * @returns {string} file basename\n     */\n\n  }, {\n    key: \"addFileToAssets\",\n    value: function addFileToAssets(filename, compilation) {\n      filename = path.resolve(compilation.compiler.context, filename);\n      return Promise.all([fsStatAsync(filename), fsReadFileAsync(filename)]).then(function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            size = _ref9[0],\n            source = _ref9[1];\n\n        return {\n          size: size,\n          source: source\n        };\n      }).catch(function () {\n        return Promise.reject(new Error('HtmlWebpackPlugin: could not load file ' + filename));\n      }).then(function (results) {\n        var basename = path.basename(filename);\n        compilation.fileDependencies.add(filename);\n        compilation.assets[basename] = {\n          source: function source() {\n            return results.source;\n          },\n          size: function size() {\n            return results.size.size;\n          }\n        };\n        return basename;\n      });\n    }\n    /**\n     * Helper to sort chunks\n     * @param {string[]} entryNames\n     * @param {string|((entryNameA: string, entryNameB: string) => number)} sortMode\n     * @param {WebpackCompilation} compilation\n     */\n\n  }, {\n    key: \"sortEntryChunks\",\n    value: function sortEntryChunks(entryNames, sortMode, compilation) {\n      // Custom function\n      if (typeof sortMode === 'function') {\n        return entryNames.sort(sortMode);\n      } // Check if the given sort mode is a valid chunkSorter sort mode\n\n\n      if (typeof chunkSorter[sortMode] !== 'undefined') {\n        return chunkSorter[sortMode](entryNames, compilation, this.options);\n      }\n\n      throw new Error('\"' + sortMode + '\" is not a valid chunk sort mode');\n    }\n    /**\n     * Return all chunks from the compilation result which match the exclude and include filters\n     * @param {any} chunks\n     * @param {string[]|'all'} includedChunks\n     * @param {string[]} excludedChunks\n     */\n\n  }, {\n    key: \"filterChunks\",\n    value: function filterChunks(chunks, includedChunks, excludedChunks) {\n      return chunks.filter(function (chunkName) {\n        // Skip if the chunks should be filtered and the given chunk was not added explicity\n        if (Array.isArray(includedChunks) && includedChunks.indexOf(chunkName) === -1) {\n          return false;\n        } // Skip if the chunks should be filtered and the given chunk was excluded explicity\n\n\n        if (Array.isArray(excludedChunks) && excludedChunks.indexOf(chunkName) !== -1) {\n          return false;\n        } // Add otherwise\n\n\n        return true;\n      });\n    }\n    /**\n     * Check if the given asset object consists only of hot-update.js files\n     *\n     * @param {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }} assets\n     */\n\n  }, {\n    key: \"isHotUpdateCompilation\",\n    value: function isHotUpdateCompilation(assets) {\n      return assets.js.length && assets.js.every(function (assetPath) {\n        return /\\.hot-update\\.js$/.test(assetPath);\n      });\n    }\n    /**\n     * The htmlWebpackPluginAssets extracts the asset information of a webpack compilation\n     * for all given entry names\n     * @param {WebpackCompilation} compilation\n     * @param {string[]} entryNames\n     * @returns {{\n        publicPath: string,\n        js: Array<string>,\n        css: Array<string>,\n        manifest?: string,\n        favicon?: string\n      }}\n     */\n\n  }, {\n    key: \"htmlWebpackPluginAssets\",\n    value: function htmlWebpackPluginAssets(compilation, childCompilationOutputName, entryNames) {\n      var _this3 = this;\n\n      var compilationHash = compilation.hash;\n      /**\n       * @type {string} the configured public path to the asset root\n       * if a path publicPath is set in the current webpack config use it otherwise\n       * fallback to a realtive path\n       */\n\n      var webpackPublicPath = compilation.mainTemplate.getPublicPath({\n        hash: compilationHash\n      });\n      var isPublicPathDefined = webpackPublicPath.trim() !== '';\n      var publicPath = isPublicPathDefined // If a hard coded public path exists use it\n      ? webpackPublicPath // If no public path was set get a relative url path\n      : path.relative(path.resolve(compilation.options.output.path, path.dirname(childCompilationOutputName)), compilation.options.output.path).split(path.sep).join('/');\n\n      if (publicPath.length && publicPath.substr(-1, 1) !== '/') {\n        publicPath += '/';\n      }\n      /**\n       * @type {{\n          publicPath: string,\n          js: Array<string>,\n          css: Array<string>,\n          manifest?: string,\n          favicon?: string\n        }}\n       */\n\n\n      var assets = {\n        // The public path\n        publicPath: publicPath,\n        // Will contain all js files\n        js: [],\n        // Will contain all css files\n        css: [],\n        // Will contain the html5 appcache manifest files if it exists\n        manifest: Object.keys(compilation.assets).find(function (assetFile) {\n          return path.extname(assetFile) === '.appcache';\n        }),\n        // Favicon\n        favicon: undefined\n      }; // Append a hash for cache busting\n\n      if (this.options.hash && assets.manifest) {\n        assets.manifest = this.appendHash(assets.manifest, compilationHash);\n      } // Extract paths to .js and .css files from the current compilation\n\n\n      var entryPointPublicPathMap = {};\n      var extensionRegexp = /\\.(css|js)(\\?|$)/;\n\n      for (var i = 0; i < entryNames.length; i++) {\n        var entryName = entryNames[i];\n        var entryPointFiles = compilation.entrypoints.get(entryName).getFiles(); // Prepend the publicPath and append the hash depending on the\n        // webpack.output.publicPath and hashOptions\n        // E.g. bundle.js -> /bundle.js?hash\n\n        var entryPointPublicPaths = entryPointFiles.map(function (chunkFile) {\n          var entryPointPublicPath = publicPath + chunkFile;\n          return _this3.options.hash ? _this3.appendHash(entryPointPublicPath, compilationHash) : entryPointPublicPath;\n        });\n        entryPointPublicPaths.forEach(function (entryPointPublicPath) {\n          var extMatch = extensionRegexp.exec(entryPointPublicPath); // Skip if the public path is not a .css or .js file\n\n          if (!extMatch) {\n            return;\n          } // Skip if this file is already known\n          // (e.g. because of common chunk optimizations)\n\n\n          if (entryPointPublicPathMap[entryPointPublicPath]) {\n            return;\n          }\n\n          entryPointPublicPathMap[entryPointPublicPath] = true; // ext will contain .js or .css\n\n          var ext = extMatch[1];\n          assets[ext].push(entryPointPublicPath);\n        });\n      }\n\n      return assets;\n    }\n    /**\n     * Converts a favicon file from disk to a webpack ressource\n     * and returns the url to the ressource\n     *\n     * @param {string|false} faviconFilePath\n     * @param {WebpackCompilation} compilation\n     * @parma {string} publicPath\n     * @returns {Promise<string|undefined>}\n     */\n\n  }, {\n    key: \"getFaviconPublicPath\",\n    value: function getFaviconPublicPath(faviconFilePath, compilation, publicPath) {\n      var _this4 = this;\n\n      if (!faviconFilePath) {\n        return Promise.resolve(undefined);\n      }\n\n      return this.addFileToAssets(faviconFilePath, compilation).then(function (faviconName) {\n        var faviconPath = publicPath + faviconName;\n\n        if (_this4.options.hash) {\n          return _this4.appendHash(faviconPath, compilation.hash);\n        }\n\n        return faviconPath;\n      });\n    }\n    /**\n     * Generate meta tags\n     * @returns {HtmlTagObject[]}\n     */\n\n  }, {\n    key: \"getMetaTags\",\n    value: function getMetaTags() {\n      var metaOptions = this.options.meta;\n\n      if (metaOptions === false) {\n        return [];\n      } // Make tags self-closing in case of xhtml\n      // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n      // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n\n\n      var metaTagAttributeObjects = Object.keys(metaOptions).map(function (metaName) {\n        var metaTagContent = metaOptions[metaName];\n        return typeof metaTagContent === 'string' ? {\n          name: metaName,\n          content: metaTagContent\n        } : metaTagContent;\n      }).filter(function (attribute) {\n        return attribute !== false;\n      }); // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n      // the html-webpack-plugin tag structure\n\n      return metaTagAttributeObjects.map(function (metaTagAttributes) {\n        if (metaTagAttributes === false) {\n          throw new Error('Invalid meta tag');\n        }\n\n        return {\n          tagName: 'meta',\n          voidTag: true,\n          attributes: metaTagAttributes\n        };\n      });\n    }\n    /**\n     * Generate all tags script for the given file paths\n     * @param {Array<string>} jsAssets\n     * @returns {Array<HtmlTagObject>}\n     */\n\n  }, {\n    key: \"generatedScriptTags\",\n    value: function generatedScriptTags(jsAssets) {\n      return jsAssets.map(function (scriptAsset) {\n        return {\n          tagName: 'script',\n          voidTag: false,\n          attributes: {\n            src: scriptAsset\n          }\n        };\n      });\n    }\n    /**\n     * Generate all style tags for the given file paths\n     * @param {Array<string>} cssAssets\n     * @returns {Array<HtmlTagObject>}\n     */\n\n  }, {\n    key: \"generateStyleTags\",\n    value: function generateStyleTags(cssAssets) {\n      return cssAssets.map(function (styleAsset) {\n        return {\n          tagName: 'link',\n          voidTag: true,\n          attributes: {\n            href: styleAsset,\n            rel: 'stylesheet'\n          }\n        };\n      });\n    }\n    /**\n     * Generate all meta tags for the given meta configuration\n     * @param {false | {\n              [name: string]:\n                false // disabled\n                | string // name content pair e.g. {viewport: 'width=device-width, initial-scale=1, shrink-to-fit=no'}`\n                | {[attributeName: string]: string|boolean} // custom properties e.g. { name:\"viewport\" content:\"width=500, initial-scale=1\" }\n          }} metaOptions\n    * @returns {Array<HtmlTagObject>}\n    */\n\n  }, {\n    key: \"generatedMetaTags\",\n    value: function generatedMetaTags(metaOptions) {\n      if (metaOptions === false) {\n        return [];\n      } // Make tags self-closing in case of xhtml\n      // Turn { \"viewport\" : \"width=500, initial-scale=1\" } into\n      // [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }]\n\n\n      var metaTagAttributeObjects = Object.keys(metaOptions).map(function (metaName) {\n        var metaTagContent = metaOptions[metaName];\n        return typeof metaTagContent === 'string' ? {\n          name: metaName,\n          content: metaTagContent\n        } : metaTagContent;\n      }).filter(function (attribute) {\n        return attribute !== false;\n      }); // Turn [{ name:\"viewport\" content:\"width=500, initial-scale=1\" }] into\n      // the html-webpack-plugin tag structure\n\n      return metaTagAttributeObjects.map(function (metaTagAttributes) {\n        if (metaTagAttributes === false) {\n          throw new Error('Invalid meta tag');\n        }\n\n        return {\n          tagName: 'meta',\n          voidTag: true,\n          attributes: metaTagAttributes\n        };\n      });\n    }\n    /**\n     * Generate a favicon tag for the given file path\n     * @param {string| undefined} faviconPath\n     * @returns {Array<HtmlTagObject>}\n     */\n\n  }, {\n    key: \"generateFaviconTags\",\n    value: function generateFaviconTags(faviconPath) {\n      if (!faviconPath) {\n        return [];\n      }\n\n      return [{\n        tagName: 'link',\n        voidTag: true,\n        attributes: {\n          rel: 'shortcut icon',\n          href: faviconPath\n        }\n      }];\n    }\n    /**\n     * Group assets to head and bottom tags\n     *\n     * @param {{\n        scripts: Array<HtmlTagObject>;\n        styles: Array<HtmlTagObject>;\n        meta: Array<HtmlTagObject>;\n      }} assetTags\n    * @param {\"body\" | \"head\"} scriptTarget\n    * @returns {{\n        headTags: Array<HtmlTagObject>;\n        bodyTags: Array<HtmlTagObject>;\n      }}\n    */\n\n  }, {\n    key: \"generateAssetGroups\",\n    value: function generateAssetGroups(assetTags, scriptTarget) {\n      /** @type {{ headTags: Array<HtmlTagObject>; bodyTags: Array<HtmlTagObject>; }} */\n      var result = {\n        headTags: [].concat(_toConsumableArray(assetTags.meta), _toConsumableArray(assetTags.styles)),\n        bodyTags: []\n      }; // Add script tags to head or body depending on\n      // the htmlPluginOptions\n\n      if (scriptTarget === 'body') {\n        var _result$bodyTags;\n\n        (_result$bodyTags = result.bodyTags).push.apply(_result$bodyTags, _toConsumableArray(assetTags.scripts));\n      } else {\n        var _result$headTags;\n\n        (_result$headTags = result.headTags).push.apply(_result$headTags, _toConsumableArray(assetTags.scripts));\n      }\n\n      return result;\n    }\n    /**\n     * Injects the assets into the given html string\n     *\n     * @param {string} html\n     * The input html\n     * @param {any} assets\n     * @param {{\n         headTags: HtmlTagObject[],\n         bodyTags: HtmlTagObject[]\n       }} assetTags\n     * The asset tags to inject\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: \"injectAssetsIntoHtml\",\n    value: function injectAssetsIntoHtml(html, assets, assetTags) {\n      var _this5 = this;\n\n      var htmlRegExp = /(<html[^>]*>)/i;\n      var headRegExp = /(<\\/head\\s*>)/i;\n      var bodyRegExp = /(<\\/body\\s*>)/i;\n      var body = assetTags.bodyTags.map(function (assetTagObject) {\n        return htmlTagObjectToString(assetTagObject, _this5.options.xhtml);\n      });\n      var head = assetTags.headTags.map(function (assetTagObject) {\n        return htmlTagObjectToString(assetTagObject, _this5.options.xhtml);\n      });\n\n      if (body.length) {\n        if (bodyRegExp.test(html)) {\n          // Append assets to body element\n          html = html.replace(bodyRegExp, function (match) {\n            return body.join('') + match;\n          });\n        } else {\n          // Append scripts to the end of the file if no <body> element exists:\n          html += body.join('');\n        }\n      }\n\n      if (head.length) {\n        // Create a head tag if none exists\n        if (!headRegExp.test(html)) {\n          if (!htmlRegExp.test(html)) {\n            html = '<head></head>' + html;\n          } else {\n            html = html.replace(htmlRegExp, function (match) {\n              return match + '<head></head>';\n            });\n          }\n        } // Append assets to head element\n\n\n        html = html.replace(headRegExp, function (match) {\n          return head.join('') + match;\n        });\n      } // Inject manifest into the opening html tag\n\n\n      if (assets.manifest) {\n        html = html.replace(/(<html[^>]*)(>)/i, function (match, start, end) {\n          // Append the manifest only if no manifest was specified\n          if (/\\smanifest\\s*=/.test(match)) {\n            return match;\n          }\n\n          return start + ' manifest=\"' + assets.manifest + '\"' + end;\n        });\n      }\n\n      return html;\n    }\n    /**\n     * Appends a cache busting hash to the query string of the url\n     * E.g. http://localhost:8080/ -> http://localhost:8080/?50c9096ba6183fd728eeb065a26ec175\n     * @param {string} url\n     * @param {string} hash\n     */\n\n  }, {\n    key: \"appendHash\",\n    value: function appendHash(url, hash) {\n      if (!url) {\n        return url;\n      }\n\n      return url + (url.indexOf('?') === -1 ? '?' : '&') + hash;\n    }\n    /**\n     * Helper to return the absolute template path with a fallback loader\n     * @param {string} template\n     * The path to the tempalate e.g. './index.html'\n     * @param {string} context\n     * The webpack base resolution path for relative paths e.g. process.cwd()\n     */\n\n  }, {\n    key: \"getFullTemplatePath\",\n    value: function getFullTemplatePath(template, context) {\n      // If the template doesn't use a loader use the lodash template loader\n      if (template.indexOf('!') === -1) {\n        template = require.resolve('./lib/loader.js') + '!' + path.resolve(context, template);\n      } // Resolve template path\n\n\n      return template.replace(/([!])([^/\\\\][^!?]+|[^/\\\\!?])($|\\?[^!?\\n]+$)/, function (match, prefix, filepath, postfix) {\n        return prefix + path.resolve(filepath) + postfix;\n      });\n    }\n    /**\n     * Helper to return a sorted unique array of all asset files out of the\n     * asset object\n     */\n\n  }, {\n    key: \"getAssetFiles\",\n    value: function getAssetFiles(assets) {\n      var files = _.uniq(Object.keys(assets).filter(function (assetType) {\n        return assetType !== 'chunks' && assets[assetType];\n      }).reduce(function (files, assetType) {\n        return files.concat(assets[assetType]);\n      }, []));\n\n      files.sort();\n      return files;\n    }\n  }]);\n\n  return HtmlWebpackPlugin;\n}();\n/**\n * The default for options.templateParameter\n * Generate the template parameters\n *\n * Generate the template parameters for the template function\n * @param {WebpackCompilation} compilation\n * @param {{\n   publicPath: string,\n   js: Array<string>,\n   css: Array<string>,\n   manifest?: string,\n   favicon?: string\n }} assets\n * @param {{\n     headTags: HtmlTagObject[],\n     bodyTags: HtmlTagObject[]\n   }} assetTags\n * @param {HtmlWebpackPluginOptions} options\n * @returns {HtmlWebpackPluginTemplateParameter}\n */\n\n\nfunction templateParametersGenerator(compilation, assets, assetTags, options) {\n  var xhtml = options.xhtml;\n\n  assetTags.headTags.toString = function () {\n    return this.map(function (assetTagObject) {\n      return htmlTagObjectToString(assetTagObject, xhtml);\n    }).join('');\n  };\n\n  assetTags.bodyTags.toString = function () {\n    return this.map(function (assetTagObject) {\n      return htmlTagObjectToString(assetTagObject, xhtml);\n    }).join('');\n  };\n\n  return {\n    compilation: compilation,\n    webpackConfig: compilation.options,\n    htmlWebpackPlugin: {\n      tags: assetTags,\n      files: assets,\n      options: options\n    }\n  };\n} // Statics:\n\n/**\n * The major version number of this plugin\n */\n\n\nHtmlWebpackPlugin.version = 4;\n/**\n * A static helper to get the hooks for this plugin\n *\n * Usage: HtmlWebpackPlugin.getHooks(compilation).HOOK_NAME.tapAsync('YourPluginName', () => { ... });\n */\n\nHtmlWebpackPlugin.getHooks = getHtmlWebpackPluginHooks;\nHtmlWebpackPlugin.createHtmlTagObject = createHtmlTagObject;\nmodule.exports = HtmlWebpackPlugin;","map":null,"metadata":{},"sourceType":"script"}