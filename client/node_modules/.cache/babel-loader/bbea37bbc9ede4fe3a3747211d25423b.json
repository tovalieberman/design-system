{"ast":null,"code":"'use strict';\n\nvar path = require('path');\n\nvar emojisList = require('emojis-list');\n\nvar getHashDigest = require('./getHashDigest');\n\nvar emojiRegex = /[\\uD800-\\uDFFF]./;\nvar emojiList = emojisList.filter(function (emoji) {\n  return emojiRegex.test(emoji);\n});\nvar emojiCache = {};\n\nfunction encodeStringToEmoji(content, length) {\n  if (emojiCache[content]) {\n    return emojiCache[content];\n  }\n\n  length = length || 1;\n  var emojis = [];\n\n  do {\n    if (!emojiList.length) {\n      throw new Error('Ran out of emoji');\n    }\n\n    var index = Math.floor(Math.random() * emojiList.length);\n    emojis.push(emojiList[index]);\n    emojiList.splice(index, 1);\n  } while (--length > 0);\n\n  var emojiEncoding = emojis.join('');\n  emojiCache[content] = emojiEncoding;\n  return emojiEncoding;\n}\n\nfunction interpolateName(loaderContext, name, options) {\n  var filename;\n\n  if (typeof name === 'function') {\n    filename = name(loaderContext.resourcePath);\n  } else {\n    filename = name || '[hash].[ext]';\n  }\n\n  var context = options.context;\n  var content = options.content;\n  var regExp = options.regExp;\n  var ext = 'bin';\n  var basename = 'file';\n  var directory = '';\n  var folder = '';\n\n  if (loaderContext.resourcePath) {\n    var parsed = path.parse(loaderContext.resourcePath);\n    var resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== 'undefined') {\n      directory = path.relative(context, resourcePath + '_').replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, '/').replace(/\\.\\.(\\/)?/g, '_$1');\n    }\n\n    if (directory.length === 1) {\n      directory = '';\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  var url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url // `hash` and `contenthash` are same in `loader-utils` context\n    // let's keep `hash` for backward compatibility\n    .replace(/\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi, function (all, hashType, digestType, maxLength) {\n      return getHashDigest(content, hashType, digestType, parseInt(maxLength, 10));\n    }).replace(/\\[emoji(?::(\\d+))?\\]/gi, function (all, length) {\n      return encodeStringToEmoji(content, parseInt(length, 10));\n    });\n  }\n\n  url = url.replace(/\\[ext\\]/gi, function () {\n    return ext;\n  }).replace(/\\[name\\]/gi, function () {\n    return basename;\n  }).replace(/\\[path\\]/gi, function () {\n    return directory;\n  }).replace(/\\[folder\\]/gi, function () {\n    return folder;\n  });\n\n  if (regExp && loaderContext.resourcePath) {\n    var match = loaderContext.resourcePath.match(new RegExp(regExp));\n    match && match.forEach(function (matched, i) {\n      url = url.replace(new RegExp('\\\\[' + i + '\\\\]', 'ig'), matched);\n    });\n  }\n\n  if (typeof loaderContext.options === 'object' && typeof loaderContext.options.customInterpolateName === 'function') {\n    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;","map":null,"metadata":{},"sourceType":"script"}