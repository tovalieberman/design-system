{"ast":null,"code":"var Marker = require('../../tokenizer/marker');\n\nvar split = require('../../utils/split');\n\nvar DEEP_SELECTOR_PATTERN = /\\/deep\\//;\nvar DOUBLE_COLON_PATTERN = /^::/;\nvar NOT_PSEUDO = ':not';\nvar PSEUDO_CLASSES_WITH_ARGUMENTS = [':dir', ':lang', ':not', ':nth-child', ':nth-last-child', ':nth-last-of-type', ':nth-of-type'];\nvar RELATION_PATTERN = /[>\\+~]/;\nvar UNMIXABLE_PSEUDO_CLASSES = [':after', ':before', ':first-letter', ':first-line', ':lang'];\nvar UNMIXABLE_PSEUDO_ELEMENTS = ['::after', '::before', '::first-letter', '::first-line'];\nvar Level = {\n  DOUBLE_QUOTE: 'double-quote',\n  SINGLE_QUOTE: 'single-quote',\n  ROOT: 'root'\n};\n\nfunction isMergeable(selector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {\n  var singleSelectors = split(selector, Marker.COMMA);\n  var singleSelector;\n  var i, l;\n\n  for (i = 0, l = singleSelectors.length; i < l; i++) {\n    singleSelector = singleSelectors[i];\n\n    if (singleSelector.length === 0 || isDeepSelector(singleSelector) || singleSelector.indexOf(Marker.COLON) > -1 && !areMergeable(singleSelector, extractPseudoFrom(singleSelector), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDeepSelector(selector) {\n  return DEEP_SELECTOR_PATTERN.test(selector);\n}\n\nfunction extractPseudoFrom(selector) {\n  var list = [];\n  var character;\n  var buffer = [];\n  var level = Level.ROOT;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isEscaped;\n  var isPseudo = false;\n  var isRelation;\n  var wasColon = false;\n  var index;\n  var len;\n\n  for (index = 0, len = selector.length; index < len; index++) {\n    character = selector[index];\n    isRelation = !isEscaped && RELATION_PATTERN.test(character);\n    isQuoted = level == Level.DOUBLE_QUOTE || level == Level.SINGLE_QUOTE;\n\n    if (isEscaped) {\n      buffer.push(character);\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.ROOT) {\n      buffer.push(character);\n      level = Level.DOUBLE_QUOTE;\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      buffer.push(character);\n      level = Level.ROOT;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.ROOT) {\n      buffer.push(character);\n      level = Level.SINGLE_QUOTE;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      buffer.push(character);\n      level = Level.ROOT;\n    } else if (isQuoted) {\n      buffer.push(character);\n    } else if (character == Marker.OPEN_ROUND_BRACKET) {\n      buffer.push(character);\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1 && isPseudo) {\n      buffer.push(character);\n      list.push(buffer.join(''));\n      roundBracketLevel--;\n      buffer = [];\n      isPseudo = false;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET) {\n      buffer.push(character);\n      roundBracketLevel--;\n    } else if (character == Marker.COLON && roundBracketLevel === 0 && isPseudo && !wasColon) {\n      list.push(buffer.join(''));\n      buffer = [];\n      buffer.push(character);\n    } else if (character == Marker.COLON && roundBracketLevel === 0 && !wasColon) {\n      buffer = [];\n      buffer.push(character);\n      isPseudo = true;\n    } else if (character == Marker.SPACE && roundBracketLevel === 0 && isPseudo) {\n      list.push(buffer.join(''));\n      buffer = [];\n      isPseudo = false;\n    } else if (isRelation && roundBracketLevel === 0 && isPseudo) {\n      list.push(buffer.join(''));\n      buffer = [];\n      isPseudo = false;\n    } else {\n      buffer.push(character);\n    }\n\n    isEscaped = character == Marker.BACK_SLASH;\n    wasColon = character == Marker.COLON;\n  }\n\n  if (buffer.length > 0 && isPseudo) {\n    list.push(buffer.join(''));\n  }\n\n  return list;\n}\n\nfunction areMergeable(selector, matches, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {\n  return areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) && needArguments(matches) && (matches.length < 2 || !someIncorrectlyChained(selector, matches)) && (matches.length < 2 || multiplePseudoMerging && allMixable(matches));\n}\n\nfunction areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) {\n  var match;\n  var name;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n    name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;\n\n    if (mergeablePseudoClasses.indexOf(name) === -1 && mergeablePseudoElements.indexOf(name) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction needArguments(matches) {\n  var match;\n  var name;\n  var bracketOpensAt;\n  var hasArguments;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n    bracketOpensAt = match.indexOf(Marker.OPEN_ROUND_BRACKET);\n    hasArguments = bracketOpensAt > -1;\n    name = hasArguments ? match.substring(0, bracketOpensAt) : match;\n\n    if (hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) == -1) {\n      return false;\n    }\n\n    if (!hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) > -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction someIncorrectlyChained(selector, matches) {\n  var positionInSelector = 0;\n  var match;\n  var matchAt;\n  var nextMatch;\n  var nextMatchAt;\n  var name;\n  var nextName;\n  var areChained;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n    nextMatch = matches[i + 1];\n\n    if (!nextMatch) {\n      break;\n    }\n\n    matchAt = selector.indexOf(match, positionInSelector);\n    nextMatchAt = selector.indexOf(match, matchAt + 1);\n    positionInSelector = nextMatchAt;\n    areChained = matchAt + match.length == nextMatchAt;\n\n    if (areChained) {\n      name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) : match;\n      nextName = nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ? nextMatch.substring(0, nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET)) : nextMatch;\n\n      if (name != NOT_PSEUDO || nextName != NOT_PSEUDO) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction allMixable(matches) {\n  var unmixableMatches = 0;\n  var match;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n\n    if (isPseudoElement(match)) {\n      unmixableMatches += UNMIXABLE_PSEUDO_ELEMENTS.indexOf(match) > -1 ? 1 : 0;\n    } else {\n      unmixableMatches += UNMIXABLE_PSEUDO_CLASSES.indexOf(match) > -1 ? 1 : 0;\n    }\n\n    if (unmixableMatches > 1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isPseudoElement(pseudo) {\n  return DOUBLE_COLON_PATTERN.test(pseudo);\n}\n\nmodule.exports = isMergeable;","map":null,"metadata":{},"sourceType":"script"}