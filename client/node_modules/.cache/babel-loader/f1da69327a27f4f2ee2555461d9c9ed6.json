{"ast":null,"code":"var canReorderSingle = require('./reorderable').canReorderSingle;\n\nvar extractProperties = require('./extract-properties');\n\nvar isMergeable = require('./is-mergeable');\n\nvar tidyRuleDuplicates = require('./tidy-rule-duplicates');\n\nvar Token = require('../../tokenizer/token');\n\nvar cloneArray = require('../../utils/clone-array');\n\nvar serializeBody = require('../../writer/one-time').body;\n\nvar serializeRules = require('../../writer/one-time').rules;\n\nfunction naturalSorter(a, b) {\n  return a > b ? 1 : -1;\n}\n\nfunction cloneAndMergeSelectors(propertyA, propertyB) {\n  var cloned = cloneArray(propertyA);\n  cloned[5] = cloned[5].concat(propertyB[5]);\n  return cloned;\n}\n\nfunction restructure(tokens, context) {\n  var options = context.options;\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var mergeLimit = options.compatibility.selectors.mergeLimit;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n  var specificityCache = context.cache.specificity;\n  var movableTokens = {};\n  var movedProperties = [];\n  var multiPropertyMoveCache = {};\n  var movedToBeDropped = [];\n  var maxCombinationsLevel = 2;\n  var ID_JOIN_CHARACTER = '%';\n\n  function sendToMultiPropertyMoveCache(position, movedProperty, allFits) {\n    for (var i = allFits.length - 1; i >= 0; i--) {\n      var fit = allFits[i][0];\n      var id = addToCache(movedProperty, fit);\n\n      if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position, multiPropertyMoveCache[id])) {\n        removeAllMatchingFromCache(id);\n        break;\n      }\n    }\n  }\n\n  function addToCache(movedProperty, fit) {\n    var id = cacheId(fit);\n    multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];\n    multiPropertyMoveCache[id].push([movedProperty, fit]);\n    return id;\n  }\n\n  function removeAllMatchingFromCache(matchId) {\n    var matchSelectors = matchId.split(ID_JOIN_CHARACTER);\n    var forRemoval = [];\n    var i;\n\n    for (var id in multiPropertyMoveCache) {\n      var selectors = id.split(ID_JOIN_CHARACTER);\n\n      for (i = selectors.length - 1; i >= 0; i--) {\n        if (matchSelectors.indexOf(selectors[i]) > -1) {\n          forRemoval.push(id);\n          break;\n        }\n      }\n    }\n\n    for (i = forRemoval.length - 1; i >= 0; i--) {\n      delete multiPropertyMoveCache[forRemoval[i]];\n    }\n  }\n\n  function cacheId(cachedTokens) {\n    var id = [];\n\n    for (var i = 0, l = cachedTokens.length; i < l; i++) {\n      id.push(serializeRules(cachedTokens[i][1]));\n    }\n\n    return id.join(ID_JOIN_CHARACTER);\n  }\n\n  function tokensToMerge(sourceTokens) {\n    var uniqueTokensWithBody = [];\n    var mergeableTokens = [];\n\n    for (var i = sourceTokens.length - 1; i >= 0; i--) {\n      if (!isMergeable(serializeRules(sourceTokens[i][1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {\n        continue;\n      }\n\n      mergeableTokens.unshift(sourceTokens[i]);\n      if (sourceTokens[i][2].length > 0 && uniqueTokensWithBody.indexOf(sourceTokens[i]) == -1) uniqueTokensWithBody.push(sourceTokens[i]);\n    }\n\n    return uniqueTokensWithBody.length > 1 ? mergeableTokens : [];\n  }\n\n  function shortenIfPossible(position, movedProperty) {\n    var name = movedProperty[0];\n    var value = movedProperty[1];\n    var key = movedProperty[4];\n    var valueSize = name.length + value.length + 1;\n    var allSelectors = [];\n    var qualifiedTokens = [];\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2) return;\n    var allFits = findAllFits(mergeableTokens, valueSize, 1);\n    var bestFit = allFits[0];\n    if (bestFit[1] > 0) return sendToMultiPropertyMoveCache(position, movedProperty, allFits);\n\n    for (var i = bestFit[0].length - 1; i >= 0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, [movedProperty], allSelectors, qualifiedTokens);\n  }\n\n  function fitSorter(fit1, fit2) {\n    return fit1[1] > fit2[1] ? 1 : fit1[1] == fit2[1] ? 0 : -1;\n  }\n\n  function findAllFits(mergeableTokens, propertySize, propertiesCount) {\n    var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);\n    return combinations.sort(fitSorter);\n  }\n\n  function allCombinations(tokensVariant, propertySize, propertiesCount, level) {\n    var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];\n\n    if (tokensVariant.length > 2 && level > 0) {\n      for (var i = tokensVariant.length - 1; i >= 0; i--) {\n        var subVariant = Array.prototype.slice.call(tokensVariant, 0);\n        subVariant.splice(i, 1);\n        differenceVariants = differenceVariants.concat(allCombinations(subVariant, propertySize, propertiesCount, level - 1));\n      }\n    }\n\n    return differenceVariants;\n  }\n\n  function sizeDifference(tokensVariant, propertySize, propertiesCount) {\n    var allSelectorsSize = 0;\n\n    for (var i = tokensVariant.length - 1; i >= 0; i--) {\n      allSelectorsSize += tokensVariant[i][2].length > propertiesCount ? serializeRules(tokensVariant[i][1]).length : -1;\n    }\n\n    return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;\n  }\n\n  function dropAsNewTokenAt(position, properties, allSelectors, mergeableTokens) {\n    var i, j, k, m;\n    var allProperties = [];\n\n    for (i = mergeableTokens.length - 1; i >= 0; i--) {\n      var mergeableToken = mergeableTokens[i];\n\n      for (j = mergeableToken[2].length - 1; j >= 0; j--) {\n        var mergeableProperty = mergeableToken[2][j];\n\n        for (k = 0, m = properties.length; k < m; k++) {\n          var property = properties[k];\n          var mergeablePropertyName = mergeableProperty[1][1];\n          var propertyName = property[0];\n          var propertyBody = property[4];\n\n          if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {\n            mergeableToken[2].splice(j, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    for (i = properties.length - 1; i >= 0; i--) {\n      allProperties.unshift(properties[i][3]);\n    }\n\n    var newToken = [Token.RULE, allSelectors, allProperties];\n    tokens.splice(position, 0, newToken);\n  }\n\n  function dropPropertiesAt(position, movedProperty) {\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n\n    if (toMove && toMove.length > 1) {\n      if (!shortenMultiMovesIfPossible(position, movedProperty)) shortenIfPossible(position, movedProperty);\n    }\n  }\n\n  function shortenMultiMovesIfPossible(position, movedProperty) {\n    var candidates = [];\n    var propertiesAndMergableTokens = [];\n    var key = movedProperty[4];\n    var j, k;\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2) return;\n\n    movableLoop: for (var value in movableTokens) {\n      var tokensList = movableTokens[value];\n\n      for (j = mergeableTokens.length - 1; j >= 0; j--) {\n        if (tokensList.indexOf(mergeableTokens[j]) == -1) continue movableLoop;\n      }\n\n      candidates.push(value);\n    }\n\n    if (candidates.length < 2) return false;\n\n    for (j = candidates.length - 1; j >= 0; j--) {\n      for (k = movedProperties.length - 1; k >= 0; k--) {\n        if (movedProperties[k][4] == candidates[j]) {\n          propertiesAndMergableTokens.unshift([movedProperties[k], mergeableTokens]);\n          break;\n        }\n      }\n    }\n\n    return processMultiPropertyMove(position, propertiesAndMergableTokens);\n  }\n\n  function processMultiPropertyMove(position, propertiesAndMergableTokens) {\n    var valueSize = 0;\n    var properties = [];\n    var property;\n\n    for (var i = propertiesAndMergableTokens.length - 1; i >= 0; i--) {\n      property = propertiesAndMergableTokens[i][0];\n      var fullValue = property[4];\n      valueSize += fullValue.length + (i > 0 ? 1 : 0);\n      properties.push(property);\n    }\n\n    var mergeableTokens = propertiesAndMergableTokens[0][1];\n    var bestFit = findAllFits(mergeableTokens, valueSize, properties.length)[0];\n    if (bestFit[1] > 0) return false;\n    var allSelectors = [];\n    var qualifiedTokens = [];\n\n    for (i = bestFit[0].length - 1; i >= 0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, properties, allSelectors, qualifiedTokens);\n\n    for (i = properties.length - 1; i >= 0; i--) {\n      property = properties[i];\n      var index = movedProperties.indexOf(property);\n      delete movableTokens[property[4]];\n      if (index > -1 && movedToBeDropped.indexOf(index) == -1) movedToBeDropped.push(index);\n    }\n\n    return true;\n  }\n\n  function boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) {\n    var propertyName = property[0];\n    var movedPropertyName = movedProperty[0];\n    if (propertyName != movedPropertyName) return false;\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n    return toMove && toMove.indexOf(token) > -1;\n  }\n\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    var isRule;\n    var j, k, m;\n    var samePropertyAt;\n\n    if (token[0] == Token.RULE) {\n      isRule = true;\n    } else if (token[0] == Token.NESTED_BLOCK) {\n      isRule = false;\n    } else {\n      continue;\n    } // We cache movedProperties.length as it may change in the loop\n\n\n    var movedCount = movedProperties.length;\n    var properties = extractProperties(token);\n    movedToBeDropped = [];\n    var unmovableInCurrentToken = [];\n\n    for (j = properties.length - 1; j >= 0; j--) {\n      for (k = j - 1; k >= 0; k--) {\n        if (!canReorderSingle(properties[j], properties[k], specificityCache)) {\n          unmovableInCurrentToken.push(j);\n          break;\n        }\n      }\n    }\n\n    for (j = properties.length - 1; j >= 0; j--) {\n      var property = properties[j];\n      var movedSameProperty = false;\n\n      for (k = 0; k < movedCount; k++) {\n        var movedProperty = movedProperties[k];\n\n        if (movedToBeDropped.indexOf(k) == -1 && (!canReorderSingle(property, movedProperty, specificityCache) && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) || movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)) {\n          dropPropertiesAt(i + 1, movedProperty, token);\n\n          if (movedToBeDropped.indexOf(k) == -1) {\n            movedToBeDropped.push(k);\n            delete movableTokens[movedProperty[4]];\n          }\n        }\n\n        if (!movedSameProperty) {\n          movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];\n\n          if (movedSameProperty) {\n            samePropertyAt = k;\n          }\n        }\n      }\n\n      if (!isRule || unmovableInCurrentToken.indexOf(j) > -1) continue;\n      var key = property[4];\n\n      if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {\n        dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);\n        movedProperties.splice(samePropertyAt, 1);\n        movableTokens[key] = [token];\n        movedSameProperty = false;\n      } else {\n        movableTokens[key] = movableTokens[key] || [];\n        movableTokens[key].push(token);\n      }\n\n      if (movedSameProperty) {\n        movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);\n      } else {\n        movedProperties.push(property);\n      }\n    }\n\n    movedToBeDropped = movedToBeDropped.sort(naturalSorter);\n\n    for (j = 0, m = movedToBeDropped.length; j < m; j++) {\n      var dropAt = movedToBeDropped[j] - j;\n      movedProperties.splice(dropAt, 1);\n    }\n  }\n\n  var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf('@charset') === 0 ? 1 : 0;\n\n  for (; position < tokens.length - 1; position++) {\n    var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf('@import') === 0;\n    var isComment = tokens[position][0] === Token.COMMENT;\n    if (!(isImportRule || isComment)) break;\n  }\n\n  for (i = 0; i < movedProperties.length; i++) {\n    dropPropertiesAt(position, movedProperties[i]);\n  }\n}\n\nmodule.exports = restructure;","map":null,"metadata":{},"sourceType":"script"}