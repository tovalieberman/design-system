{"ast":null,"code":"'use strict';\n\nvar CleanCSS = require('clean-css');\n\nvar decode = require('he').decode;\n\nvar HTMLParser = require('./htmlparser').HTMLParser;\n\nvar RelateUrl = require('relateurl');\n\nvar TokenChain = require('./tokenchain');\n\nvar UglifyJS = require('uglify-js');\n\nvar utils = require('./utils');\n\nfunction trimWhitespace(str) {\n  return str && str.replace(/^[ \\n\\r\\t\\f]+/, '').replace(/[ \\n\\r\\t\\f]+$/, '');\n}\n\nfunction collapseWhitespaceAll(str) {\n  // Non-breaking space is specifically handled inside the replacer function here:\n  return str && str.replace(/[ \\n\\r\\t\\f\\xA0]+/g, function (spaces) {\n    return spaces === '\\t' ? '\\t' : spaces.replace(/(^|\\xA0+)[^\\xA0]+/g, '$1 ');\n  });\n}\n\nfunction collapseWhitespace(str, options, trimLeft, trimRight, collapseAll) {\n  var lineBreakBefore = '',\n      lineBreakAfter = '';\n\n  if (options.preserveLineBreaks) {\n    str = str.replace(/^[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*/, function () {\n      lineBreakBefore = '\\n';\n      return '';\n    }).replace(/[ \\n\\r\\t\\f]*?[\\n\\r][ \\n\\r\\t\\f]*$/, function () {\n      lineBreakAfter = '\\n';\n      return '';\n    });\n  }\n\n  if (trimLeft) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/^[ \\n\\r\\t\\f\\xA0]+/, function (spaces) {\n      var conservative = !lineBreakBefore && options.conservativeCollapse;\n\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n\n      return spaces.replace(/^[^\\xA0]+/, '').replace(/(\\xA0+)[^\\xA0]+/g, '$1 ') || (conservative ? ' ' : '');\n    });\n  }\n\n  if (trimRight) {\n    // Non-breaking space is specifically handled inside the replacer function here:\n    str = str.replace(/[ \\n\\r\\t\\f\\xA0]+$/, function (spaces) {\n      var conservative = !lineBreakAfter && options.conservativeCollapse;\n\n      if (conservative && spaces === '\\t') {\n        return '\\t';\n      }\n\n      return spaces.replace(/[^\\xA0]+(\\xA0+)/g, ' $1').replace(/[^\\xA0]+$/, '') || (conservative ? ' ' : '');\n    });\n  }\n\n  if (collapseAll) {\n    // strip non space whitespace then compress spaces to one\n    str = collapseWhitespaceAll(str);\n  }\n\n  return lineBreakBefore + str + lineBreakAfter;\n}\n\nvar createMapFromString = utils.createMapFromString; // non-empty tags that will maintain whitespace around them\n\nvar inlineTags = createMapFromString('a,abbr,acronym,b,bdi,bdo,big,button,cite,code,del,dfn,em,font,i,ins,kbd,label,mark,math,nobr,object,q,rp,rt,rtc,ruby,s,samp,select,small,span,strike,strong,sub,sup,svg,textarea,time,tt,u,var'); // non-empty tags that will maintain whitespace within them\n\nvar inlineTextTags = createMapFromString('a,abbr,acronym,b,big,del,em,font,i,ins,kbd,mark,nobr,rp,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var'); // self-closing tags that will maintain whitespace around them\n\nvar selfClosingInlineTags = createMapFromString('comment,img,input,wbr');\n\nfunction collapseWhitespaceSmart(str, prevTag, nextTag, options) {\n  var trimLeft = prevTag && !selfClosingInlineTags(prevTag);\n\n  if (trimLeft && !options.collapseInlineTagWhitespace) {\n    trimLeft = prevTag.charAt(0) === '/' ? !inlineTags(prevTag.slice(1)) : !inlineTextTags(prevTag);\n  }\n\n  var trimRight = nextTag && !selfClosingInlineTags(nextTag);\n\n  if (trimRight && !options.collapseInlineTagWhitespace) {\n    trimRight = nextTag.charAt(0) === '/' ? !inlineTextTags(nextTag.slice(1)) : !inlineTags(nextTag);\n  }\n\n  return collapseWhitespace(str, options, trimLeft, trimRight, prevTag && nextTag);\n}\n\nfunction isConditionalComment(text) {\n  return /^\\[if\\s[^\\]]+]|\\[endif]$/.test(text);\n}\n\nfunction isIgnoredComment(text, options) {\n  for (var i = 0, len = options.ignoreCustomComments.length; i < len; i++) {\n    if (options.ignoreCustomComments[i].test(text)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isEventAttribute(attrName, options) {\n  var patterns = options.customEventAttributes;\n\n  if (patterns) {\n    for (var i = patterns.length; i--;) {\n      if (patterns[i].test(attrName)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return /^on[a-z]{3,}$/.test(attrName);\n}\n\nfunction canRemoveAttributeQuotes(value) {\n  // https://mathiasbynens.be/notes/unquoted-attribute-values\n  return /^[^ \\t\\n\\f\\r\"'`=<>]+$/.test(value);\n}\n\nfunction attributesInclude(attributes, attribute) {\n  for (var i = attributes.length; i--;) {\n    if (attributes[i].name.toLowerCase() === attribute) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isAttributeRedundant(tag, attrName, attrValue, attrs) {\n  attrValue = attrValue ? trimWhitespace(attrValue.toLowerCase()) : '';\n  return tag === 'script' && attrName === 'language' && attrValue === 'javascript' || tag === 'form' && attrName === 'method' && attrValue === 'get' || tag === 'input' && attrName === 'type' && attrValue === 'text' || tag === 'script' && attrName === 'charset' && !attributesInclude(attrs, 'src') || tag === 'a' && attrName === 'name' && attributesInclude(attrs, 'id') || tag === 'area' && attrName === 'shape' && attrValue === 'rect';\n} // https://mathiasbynens.be/demo/javascript-mime-type\n// https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-type\n\n\nvar executableScriptsMimetypes = utils.createMap(['text/javascript', 'text/ecmascript', 'text/jscript', 'application/javascript', 'application/x-javascript', 'application/ecmascript']);\n\nfunction isScriptTypeAttribute(attrValue) {\n  attrValue = trimWhitespace(attrValue.split(/;/, 2)[0]).toLowerCase();\n  return attrValue === '' || executableScriptsMimetypes(attrValue);\n}\n\nfunction isExecutableScript(tag, attrs) {\n  if (tag !== 'script') {\n    return false;\n  }\n\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    var attrName = attrs[i].name.toLowerCase();\n\n    if (attrName === 'type') {\n      return isScriptTypeAttribute(attrs[i].value);\n    }\n  }\n\n  return true;\n}\n\nfunction isStyleLinkTypeAttribute(attrValue) {\n  attrValue = trimWhitespace(attrValue).toLowerCase();\n  return attrValue === '' || attrValue === 'text/css';\n}\n\nfunction isStyleSheet(tag, attrs) {\n  if (tag !== 'style') {\n    return false;\n  }\n\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    var attrName = attrs[i].name.toLowerCase();\n\n    if (attrName === 'type') {\n      return isStyleLinkTypeAttribute(attrs[i].value);\n    }\n  }\n\n  return true;\n}\n\nvar isSimpleBoolean = createMapFromString('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible');\nvar isBooleanValue = createMapFromString('true,false');\n\nfunction isBooleanAttribute(attrName, attrValue) {\n  return isSimpleBoolean(attrName) || attrName === 'draggable' && !isBooleanValue(attrValue);\n}\n\nfunction isUriTypeAttribute(attrName, tag) {\n  return /^(?:a|area|link|base)$/.test(tag) && attrName === 'href' || tag === 'img' && /^(?:src|longdesc|usemap)$/.test(attrName) || tag === 'object' && /^(?:classid|codebase|data|usemap)$/.test(attrName) || tag === 'q' && attrName === 'cite' || tag === 'blockquote' && attrName === 'cite' || (tag === 'ins' || tag === 'del') && attrName === 'cite' || tag === 'form' && attrName === 'action' || tag === 'input' && (attrName === 'src' || attrName === 'usemap') || tag === 'head' && attrName === 'profile' || tag === 'script' && (attrName === 'src' || attrName === 'for');\n}\n\nfunction isNumberTypeAttribute(attrName, tag) {\n  return /^(?:a|area|object|button)$/.test(tag) && attrName === 'tabindex' || tag === 'input' && (attrName === 'maxlength' || attrName === 'tabindex') || tag === 'select' && (attrName === 'size' || attrName === 'tabindex') || tag === 'textarea' && /^(?:rows|cols|tabindex)$/.test(attrName) || tag === 'colgroup' && attrName === 'span' || tag === 'col' && attrName === 'span' || (tag === 'th' || tag === 'td') && (attrName === 'rowspan' || attrName === 'colspan');\n}\n\nfunction isLinkType(tag, attrs, value) {\n  if (tag !== 'link') {\n    return false;\n  }\n\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'rel' && attrs[i].value === value) {\n      return true;\n    }\n  }\n}\n\nfunction isMediaQuery(tag, attrs, attrName) {\n  return attrName === 'media' && (isLinkType(tag, attrs, 'stylesheet') || isStyleSheet(tag, attrs));\n}\n\nvar srcsetTags = createMapFromString('img,source');\n\nfunction isSrcset(attrName, tag) {\n  return attrName === 'srcset' && srcsetTags(tag);\n}\n\nfunction cleanAttributeValue(tag, attrName, attrValue, options, attrs) {\n  if (isEventAttribute(attrName, options)) {\n    attrValue = trimWhitespace(attrValue).replace(/^javascript:\\s*/i, '');\n    return options.minifyJS(attrValue, true);\n  } else if (attrName === 'class') {\n    attrValue = trimWhitespace(attrValue);\n\n    if (options.sortClassName) {\n      attrValue = options.sortClassName(attrValue);\n    } else {\n      attrValue = collapseWhitespaceAll(attrValue);\n    }\n\n    return attrValue;\n  } else if (isUriTypeAttribute(attrName, tag)) {\n    attrValue = trimWhitespace(attrValue);\n    return isLinkType(tag, attrs, 'canonical') ? attrValue : options.minifyURLs(attrValue);\n  } else if (isNumberTypeAttribute(attrName, tag)) {\n    return trimWhitespace(attrValue);\n  } else if (attrName === 'style') {\n    attrValue = trimWhitespace(attrValue);\n\n    if (attrValue) {\n      if (/;$/.test(attrValue) && !/&#?[0-9a-zA-Z]+;$/.test(attrValue)) {\n        attrValue = attrValue.replace(/\\s*;$/, ';');\n      }\n\n      attrValue = options.minifyCSS(attrValue, 'inline');\n    }\n\n    return attrValue;\n  } else if (isSrcset(attrName, tag)) {\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#attr-img-srcset\n    attrValue = trimWhitespace(attrValue).split(/\\s+,\\s*|\\s*,\\s+/).map(function (candidate) {\n      var url = candidate;\n      var descriptor = '';\n      var match = candidate.match(/\\s+([1-9][0-9]*w|[0-9]+(?:\\.[0-9]+)?x)$/);\n\n      if (match) {\n        url = url.slice(0, -match[0].length);\n        var num = +match[1].slice(0, -1);\n        var suffix = match[1].slice(-1);\n\n        if (num !== 1 || suffix !== 'x') {\n          descriptor = ' ' + num + suffix;\n        }\n      }\n\n      return options.minifyURLs(url) + descriptor;\n    }).join(', ');\n  } else if (isMetaViewport(tag, attrs) && attrName === 'content') {\n    attrValue = attrValue.replace(/\\s+/g, '').replace(/[0-9]+\\.[0-9]+/g, function (numString) {\n      // \"0.90000\" -> \"0.9\"\n      // \"1.0\" -> \"1\"\n      // \"1.0001\" -> \"1.0001\" (unchanged)\n      return (+numString).toString();\n    });\n  } else if (options.customAttrCollapse && options.customAttrCollapse.test(attrName)) {\n    attrValue = attrValue.replace(/\\n+|\\r+|\\s{2,}/g, '');\n  } else if (tag === 'script' && attrName === 'type') {\n    attrValue = trimWhitespace(attrValue.replace(/\\s*;\\s*/g, ';'));\n  } else if (isMediaQuery(tag, attrs, attrName)) {\n    attrValue = trimWhitespace(attrValue);\n    return options.minifyCSS(attrValue, 'media');\n  }\n\n  return attrValue;\n}\n\nfunction isMetaViewport(tag, attrs) {\n  if (tag !== 'meta') {\n    return false;\n  }\n\n  for (var i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i].name === 'name' && attrs[i].value === 'viewport') {\n      return true;\n    }\n  }\n}\n\nfunction ignoreCSS(id) {\n  return '/* clean-css ignore:start */' + id + '/* clean-css ignore:end */';\n} // Wrap CSS declarations for CleanCSS > 3.x\n// See https://github.com/jakubpawlowicz/clean-css/issues/418\n\n\nfunction wrapCSS(text, type) {\n  switch (type) {\n    case 'inline':\n      return '*{' + text + '}';\n\n    case 'media':\n      return '@media ' + text + '{a{top:0}}';\n\n    default:\n      return text;\n  }\n}\n\nfunction unwrapCSS(text, type) {\n  var matches;\n\n  switch (type) {\n    case 'inline':\n      matches = text.match(/^\\*\\{([\\s\\S]*)\\}$/);\n      break;\n\n    case 'media':\n      matches = text.match(/^@media ([\\s\\S]*?)\\s*{[\\s\\S]*}$/);\n      break;\n  }\n\n  return matches ? matches[1] : text;\n}\n\nfunction cleanConditionalComment(comment, options) {\n  return options.processConditionalComments ? comment.replace(/^(\\[if\\s[^\\]]+]>)([\\s\\S]*?)(<!\\[endif])$/, function (match, prefix, text, suffix) {\n    return prefix + minify(text, options, true) + suffix;\n  }) : comment;\n}\n\nfunction processScript(text, options, currentAttrs) {\n  for (var i = 0, len = currentAttrs.length; i < len; i++) {\n    if (currentAttrs[i].name.toLowerCase() === 'type' && options.processScripts.indexOf(currentAttrs[i].value) > -1) {\n      return minify(text, options);\n    }\n  }\n\n  return text;\n} // Tag omission rules from https://html.spec.whatwg.org/multipage/syntax.html#optional-tags\n// with the following deviations:\n// - retain <body> if followed by <noscript>\n// - </rb>, </rt>, </rtc>, </rp> & </tfoot> follow https://www.w3.org/TR/html5/syntax.html#optional-tags\n// - retain all tags which are adjacent to non-standard HTML tags\n\n\nvar optionalStartTags = createMapFromString('html,head,body,colgroup,tbody');\nvar optionalEndTags = createMapFromString('html,head,body,li,dt,dd,p,rb,rt,rtc,rp,optgroup,option,colgroup,caption,thead,tbody,tfoot,tr,td,th');\nvar headerTags = createMapFromString('meta,link,script,style,template,noscript');\nvar descriptionTags = createMapFromString('dt,dd');\nvar pBlockTags = createMapFromString('address,article,aside,blockquote,details,div,dl,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,main,menu,nav,ol,p,pre,section,table,ul');\nvar pInlineTags = createMapFromString('a,audio,del,ins,map,noscript,video');\nvar rubyTags = createMapFromString('rb,rt,rtc,rp');\nvar rtcTag = createMapFromString('rb,rtc,rp');\nvar optionTag = createMapFromString('option,optgroup');\nvar tableContentTags = createMapFromString('tbody,tfoot');\nvar tableSectionTags = createMapFromString('thead,tbody,tfoot');\nvar cellTags = createMapFromString('td,th');\nvar topLevelTags = createMapFromString('html,head,body');\nvar compactTags = createMapFromString('html,body');\nvar looseTags = createMapFromString('head,colgroup,caption');\nvar trailingTags = createMapFromString('dt,thead');\nvar htmlTags = createMapFromString('a,abbr,acronym,address,applet,area,article,aside,audio,b,base,basefont,bdi,bdo,bgsound,big,blink,blockquote,body,br,button,canvas,caption,center,cite,code,col,colgroup,command,content,data,datalist,dd,del,details,dfn,dialog,dir,div,dl,dt,element,em,embed,fieldset,figcaption,figure,font,footer,form,frame,frameset,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,image,img,input,ins,isindex,kbd,keygen,label,legend,li,link,listing,main,map,mark,marquee,menu,menuitem,meta,meter,multicol,nav,nobr,noembed,noframes,noscript,object,ol,optgroup,option,output,p,param,picture,plaintext,pre,progress,q,rb,rp,rt,rtc,ruby,s,samp,script,section,select,shadow,small,source,spacer,span,strike,strong,style,sub,summary,sup,table,tbody,td,template,textarea,tfoot,th,thead,time,title,tr,track,tt,u,ul,var,video,wbr,xmp');\n\nfunction canRemoveParentTag(optionalStartTag, tag) {\n  switch (optionalStartTag) {\n    case 'html':\n    case 'head':\n      return true;\n\n    case 'body':\n      return !headerTags(tag);\n\n    case 'colgroup':\n      return tag === 'col';\n\n    case 'tbody':\n      return tag === 'tr';\n  }\n\n  return false;\n}\n\nfunction isStartTagMandatory(optionalEndTag, tag) {\n  switch (tag) {\n    case 'colgroup':\n      return optionalEndTag === 'colgroup';\n\n    case 'tbody':\n      return tableSectionTags(optionalEndTag);\n  }\n\n  return false;\n}\n\nfunction canRemovePrecedingTag(optionalEndTag, tag) {\n  switch (optionalEndTag) {\n    case 'html':\n    case 'head':\n    case 'body':\n    case 'colgroup':\n    case 'caption':\n      return true;\n\n    case 'li':\n    case 'optgroup':\n    case 'tr':\n      return tag === optionalEndTag;\n\n    case 'dt':\n    case 'dd':\n      return descriptionTags(tag);\n\n    case 'p':\n      return pBlockTags(tag);\n\n    case 'rb':\n    case 'rt':\n    case 'rp':\n      return rubyTags(tag);\n\n    case 'rtc':\n      return rtcTag(tag);\n\n    case 'option':\n      return optionTag(tag);\n\n    case 'thead':\n    case 'tbody':\n      return tableContentTags(tag);\n\n    case 'tfoot':\n      return tag === 'tbody';\n\n    case 'td':\n    case 'th':\n      return cellTags(tag);\n  }\n\n  return false;\n}\n\nvar reEmptyAttribute = new RegExp('^(?:class|id|style|title|lang|dir|on(?:focus|blur|change|click|dblclick|mouse(' + '?:down|up|over|move|out)|key(?:press|down|up)))$');\n\nfunction canDeleteEmptyAttribute(tag, attrName, attrValue, options) {\n  var isValueEmpty = !attrValue || /^\\s*$/.test(attrValue);\n\n  if (!isValueEmpty) {\n    return false;\n  }\n\n  if (typeof options.removeEmptyAttributes === 'function') {\n    return options.removeEmptyAttributes(attrName, tag);\n  }\n\n  return tag === 'input' && attrName === 'value' || reEmptyAttribute.test(attrName);\n}\n\nfunction hasAttrName(name, attrs) {\n  for (var i = attrs.length - 1; i >= 0; i--) {\n    if (attrs[i].name === name) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction canRemoveElement(tag, attrs) {\n  switch (tag) {\n    case 'textarea':\n      return false;\n\n    case 'audio':\n    case 'script':\n    case 'video':\n      if (hasAttrName('src', attrs)) {\n        return false;\n      }\n\n      break;\n\n    case 'iframe':\n      if (hasAttrName('src', attrs) || hasAttrName('srcdoc', attrs)) {\n        return false;\n      }\n\n      break;\n\n    case 'object':\n      if (hasAttrName('data', attrs)) {\n        return false;\n      }\n\n      break;\n\n    case 'applet':\n      if (hasAttrName('code', attrs)) {\n        return false;\n      }\n\n      break;\n  }\n\n  return true;\n}\n\nfunction canCollapseWhitespace(tag) {\n  return !/^(?:script|style|pre|textarea)$/.test(tag);\n}\n\nfunction canTrimWhitespace(tag) {\n  return !/^(?:pre|textarea)$/.test(tag);\n}\n\nfunction normalizeAttr(attr, attrs, tag, options) {\n  var attrName = options.name(attr.name),\n      attrValue = attr.value;\n\n  if (options.decodeEntities && attrValue) {\n    attrValue = decode(attrValue, {\n      isAttributeValue: true\n    });\n  }\n\n  if (options.removeRedundantAttributes && isAttributeRedundant(tag, attrName, attrValue, attrs) || options.removeScriptTypeAttributes && tag === 'script' && attrName === 'type' && isScriptTypeAttribute(attrValue) || options.removeStyleLinkTypeAttributes && (tag === 'style' || tag === 'link') && attrName === 'type' && isStyleLinkTypeAttribute(attrValue)) {\n    return;\n  }\n\n  if (attrValue) {\n    attrValue = cleanAttributeValue(tag, attrName, attrValue, options, attrs);\n  }\n\n  if (options.removeEmptyAttributes && canDeleteEmptyAttribute(tag, attrName, attrValue, options)) {\n    return;\n  }\n\n  if (options.decodeEntities && attrValue) {\n    attrValue = attrValue.replace(/&(#?[0-9a-zA-Z]+;)/g, '&amp;$1');\n  }\n\n  return {\n    attr: attr,\n    name: attrName,\n    value: attrValue\n  };\n}\n\nfunction buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr) {\n  var attrName = normalized.name,\n      attrValue = normalized.value,\n      attr = normalized.attr,\n      attrQuote = attr.quote,\n      attrFragment,\n      emittedAttrValue;\n\n  if (typeof attrValue !== 'undefined' && (!options.removeAttributeQuotes || ~attrValue.indexOf(uidAttr) || !canRemoveAttributeQuotes(attrValue))) {\n    if (!options.preventAttributesEscaping) {\n      if (typeof options.quoteCharacter === 'undefined') {\n        var apos = (attrValue.match(/'/g) || []).length;\n        var quot = (attrValue.match(/\"/g) || []).length;\n        attrQuote = apos < quot ? '\\'' : '\"';\n      } else {\n        attrQuote = options.quoteCharacter === '\\'' ? '\\'' : '\"';\n      }\n\n      if (attrQuote === '\"') {\n        attrValue = attrValue.replace(/\"/g, '&#34;');\n      } else {\n        attrValue = attrValue.replace(/'/g, '&#39;');\n      }\n    }\n\n    emittedAttrValue = attrQuote + attrValue + attrQuote;\n\n    if (!isLast && !options.removeTagWhitespace) {\n      emittedAttrValue += ' ';\n    }\n  } // make sure trailing slash is not interpreted as HTML self-closing tag\n  else if (isLast && !hasUnarySlash && !/\\/$/.test(attrValue)) {\n      emittedAttrValue = attrValue;\n    } else {\n      emittedAttrValue = attrValue + ' ';\n    }\n\n  if (typeof attrValue === 'undefined' || options.collapseBooleanAttributes && isBooleanAttribute(attrName.toLowerCase(), attrValue.toLowerCase())) {\n    attrFragment = attrName;\n\n    if (!isLast) {\n      attrFragment += ' ';\n    }\n  } else {\n    attrFragment = attrName + attr.customAssign + emittedAttrValue;\n  }\n\n  return attr.customOpen + attrFragment + attr.customClose;\n}\n\nfunction identity(value) {\n  return value;\n}\n\nfunction processOptions(values) {\n  var options = {\n    name: function name(_name) {\n      return _name.toLowerCase();\n    },\n    canCollapseWhitespace: canCollapseWhitespace,\n    canTrimWhitespace: canTrimWhitespace,\n    html5: true,\n    ignoreCustomComments: [/^!/],\n    ignoreCustomFragments: [/<%[\\s\\S]*?%>/, /<\\?[\\s\\S]*?\\?>/],\n    includeAutoGeneratedTags: true,\n    log: identity,\n    minifyCSS: identity,\n    minifyJS: identity,\n    minifyURLs: identity\n  };\n  Object.keys(values).forEach(function (key) {\n    var value = values[key];\n\n    if (key === 'caseSensitive') {\n      if (value) {\n        options.name = identity;\n      }\n    } else if (key === 'log') {\n      if (typeof value === 'function') {\n        options.log = value;\n      }\n    } else if (key === 'minifyCSS' && typeof value !== 'function') {\n      if (!value) {\n        return;\n      }\n\n      if (typeof value !== 'object') {\n        value = {};\n      }\n\n      options.minifyCSS = function (text, type) {\n        text = text.replace(/(url\\s*\\(\\s*)(\"|'|)(.*?)\\2(\\s*\\))/ig, function (match, prefix, quote, url, suffix) {\n          return prefix + quote + options.minifyURLs(url) + quote + suffix;\n        });\n        var cleanCssOutput = new CleanCSS(value).minify(wrapCSS(text, type));\n\n        if (cleanCssOutput.errors.length > 0) {\n          cleanCssOutput.errors.forEach(options.log);\n          return text;\n        }\n\n        return unwrapCSS(cleanCssOutput.styles, type);\n      };\n    } else if (key === 'minifyJS' && typeof value !== 'function') {\n      if (!value) {\n        return;\n      }\n\n      if (typeof value !== 'object') {\n        value = {};\n      }\n\n      (value.parse || (value.parse = {})).bare_returns = false;\n\n      options.minifyJS = function (text, inline) {\n        var start = text.match(/^\\s*<!--.*/);\n        var code = start ? text.slice(start[0].length).replace(/\\n\\s*-->\\s*$/, '') : text;\n        value.parse.bare_returns = inline;\n        var result = UglifyJS.minify(code, value);\n\n        if (result.error) {\n          options.log(result.error);\n          return text;\n        }\n\n        return result.code.replace(/;$/, '');\n      };\n    } else if (key === 'minifyURLs' && typeof value !== 'function') {\n      if (!value) {\n        return;\n      }\n\n      if (typeof value === 'string') {\n        value = {\n          site: value\n        };\n      } else if (typeof value !== 'object') {\n        value = {};\n      }\n\n      options.minifyURLs = function (text) {\n        try {\n          return RelateUrl.relate(text, value);\n        } catch (err) {\n          options.log(err);\n          return text;\n        }\n      };\n    } else {\n      options[key] = value;\n    }\n  });\n  return options;\n}\n\nfunction uniqueId(value) {\n  var id;\n\n  do {\n    id = Math.random().toString(36).replace(/^0\\.[0-9]*/, '');\n  } while (~value.indexOf(id));\n\n  return id;\n}\n\nvar specialContentTags = createMapFromString('script,style');\n\nfunction createSortFns(value, options, uidIgnore, uidAttr) {\n  var attrChains = options.sortAttributes && Object.create(null);\n  var classChain = options.sortClassName && new TokenChain();\n\n  function attrNames(attrs) {\n    return attrs.map(function (attr) {\n      return options.name(attr.name);\n    });\n  }\n\n  function shouldSkipUID(token, uid) {\n    return !uid || token.indexOf(uid) === -1;\n  }\n\n  function shouldSkipUIDs(token) {\n    return shouldSkipUID(token, uidIgnore) && shouldSkipUID(token, uidAttr);\n  }\n\n  function scan(input) {\n    var currentTag, currentType;\n    new HTMLParser(input, {\n      start: function start(tag, attrs) {\n        if (attrChains) {\n          if (!attrChains[tag]) {\n            attrChains[tag] = new TokenChain();\n          }\n\n          attrChains[tag].add(attrNames(attrs).filter(shouldSkipUIDs));\n        }\n\n        for (var i = 0, len = attrs.length; i < len; i++) {\n          var attr = attrs[i];\n\n          if (classChain && attr.value && options.name(attr.name) === 'class') {\n            classChain.add(trimWhitespace(attr.value).split(/[ \\t\\n\\f\\r]+/).filter(shouldSkipUIDs));\n          } else if (options.processScripts && attr.name.toLowerCase() === 'type') {\n            currentTag = tag;\n            currentType = attr.value;\n          }\n        }\n      },\n      end: function end() {\n        currentTag = '';\n      },\n      chars: function chars(text) {\n        if (options.processScripts && specialContentTags(currentTag) && options.processScripts.indexOf(currentType) > -1) {\n          scan(text);\n        }\n      }\n    });\n  }\n\n  var log = options.log;\n  options.log = identity;\n  options.sortAttributes = false;\n  options.sortClassName = false;\n  scan(minify(value, options));\n  options.log = log;\n\n  if (attrChains) {\n    var attrSorters = Object.create(null);\n\n    for (var tag in attrChains) {\n      attrSorters[tag] = attrChains[tag].createSorter();\n    }\n\n    options.sortAttributes = function (tag, attrs) {\n      var sorter = attrSorters[tag];\n\n      if (sorter) {\n        var attrMap = Object.create(null);\n        var names = attrNames(attrs);\n        names.forEach(function (name, index) {\n          (attrMap[name] || (attrMap[name] = [])).push(attrs[index]);\n        });\n        sorter.sort(names).forEach(function (name, index) {\n          attrs[index] = attrMap[name].shift();\n        });\n      }\n    };\n  }\n\n  if (classChain) {\n    var sorter = classChain.createSorter();\n\n    options.sortClassName = function (value) {\n      return sorter.sort(value.split(/[ \\n\\f\\r]+/)).join(' ');\n    };\n  }\n}\n\nfunction minify(value, options, partialMarkup) {\n  if (options.collapseWhitespace) {\n    value = collapseWhitespace(value, options, true, true);\n  }\n\n  var buffer = [],\n      charsPrevTag,\n      currentChars = '',\n      hasChars,\n      currentTag = '',\n      currentAttrs = [],\n      stackNoTrimWhitespace = [],\n      stackNoCollapseWhitespace = [],\n      optionalStartTag = '',\n      optionalEndTag = '',\n      ignoredMarkupChunks = [],\n      ignoredCustomMarkupChunks = [],\n      uidIgnore,\n      uidAttr,\n      uidPattern; // temporarily replace ignored chunks with comments,\n  // so that we don't have to worry what's there.\n  // for all we care there might be\n  // completely-horribly-broken-alien-non-html-emoj-cthulhu-filled content\n\n  value = value.replace(/<!-- htmlmin:ignore -->([\\s\\S]*?)<!-- htmlmin:ignore -->/g, function (match, group1) {\n    if (!uidIgnore) {\n      uidIgnore = uniqueId(value);\n      var pattern = new RegExp('^' + uidIgnore + '([0-9]+)$');\n\n      if (options.ignoreCustomComments) {\n        options.ignoreCustomComments = options.ignoreCustomComments.slice();\n      } else {\n        options.ignoreCustomComments = [];\n      }\n\n      options.ignoreCustomComments.push(pattern);\n    }\n\n    var token = '<!--' + uidIgnore + ignoredMarkupChunks.length + '-->';\n    ignoredMarkupChunks.push(group1);\n    return token;\n  });\n  var customFragments = options.ignoreCustomFragments.map(function (re) {\n    return re.source;\n  });\n\n  if (customFragments.length) {\n    var reCustomIgnore = new RegExp('\\\\s*(?:' + customFragments.join('|') + ')+\\\\s*', 'g'); // temporarily replace custom ignored fragments with unique attributes\n\n    value = value.replace(reCustomIgnore, function (match) {\n      if (!uidAttr) {\n        uidAttr = uniqueId(value);\n        uidPattern = new RegExp('(\\\\s*)' + uidAttr + '([0-9]+)(\\\\s*)', 'g');\n\n        if (options.minifyCSS) {\n          options.minifyCSS = function (fn) {\n            return function (text, type) {\n              text = text.replace(uidPattern, function (match, prefix, index) {\n                var chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + chunks[2];\n              });\n              var ids = [];\n              new CleanCSS().minify(wrapCSS(text, type)).warnings.forEach(function (warning) {\n                var match = uidPattern.exec(warning);\n\n                if (match) {\n                  var id = uidAttr + match[2];\n                  text = text.replace(id, ignoreCSS(id));\n                  ids.push(id);\n                }\n              });\n              text = fn(text, type);\n              ids.forEach(function (id) {\n                text = text.replace(ignoreCSS(id), id);\n              });\n              return text;\n            };\n          }(options.minifyCSS);\n        }\n\n        if (options.minifyJS) {\n          options.minifyJS = function (fn) {\n            return function (text, type) {\n              return fn(text.replace(uidPattern, function (match, prefix, index) {\n                var chunks = ignoredCustomMarkupChunks[+index];\n                return chunks[1] + uidAttr + index + chunks[2];\n              }), type);\n            };\n          }(options.minifyJS);\n        }\n      }\n\n      var token = uidAttr + ignoredCustomMarkupChunks.length;\n      ignoredCustomMarkupChunks.push(/^(\\s*)[\\s\\S]*?(\\s*)$/.exec(match));\n      return '\\t' + token + '\\t';\n    });\n  }\n\n  if (options.sortAttributes && typeof options.sortAttributes !== 'function' || options.sortClassName && typeof options.sortClassName !== 'function') {\n    createSortFns(value, options, uidIgnore, uidAttr);\n  }\n\n  function _canCollapseWhitespace(tag, attrs) {\n    return options.canCollapseWhitespace(tag, attrs, canCollapseWhitespace);\n  }\n\n  function _canTrimWhitespace(tag, attrs) {\n    return options.canTrimWhitespace(tag, attrs, canTrimWhitespace);\n  }\n\n  function removeStartTag() {\n    var index = buffer.length - 1;\n\n    while (index > 0 && !/^<[^/!]/.test(buffer[index])) {\n      index--;\n    }\n\n    buffer.length = Math.max(0, index);\n  }\n\n  function removeEndTag() {\n    var index = buffer.length - 1;\n\n    while (index > 0 && !/^<\\//.test(buffer[index])) {\n      index--;\n    }\n\n    buffer.length = Math.max(0, index);\n  } // look for trailing whitespaces, bypass any inline tags\n\n\n  function trimTrailingWhitespace(index, nextTag) {\n    for (var endTag = null; index >= 0 && _canTrimWhitespace(endTag); index--) {\n      var str = buffer[index];\n      var match = str.match(/^<\\/([\\w:-]+)>$/);\n\n      if (match) {\n        endTag = match[1];\n      } else if (/>$/.test(str) || (buffer[index] = collapseWhitespaceSmart(str, null, nextTag, options))) {\n        break;\n      }\n    }\n  } // look for trailing whitespaces from previously processed text\n  // which may not be trimmed due to a following comment or an empty\n  // element which has now been removed\n\n\n  function squashTrailingWhitespace(nextTag) {\n    var charsIndex = buffer.length - 1;\n\n    if (buffer.length > 1) {\n      var item = buffer[buffer.length - 1];\n\n      if (/^(?:<!|$)/.test(item) && item.indexOf(uidIgnore) === -1) {\n        charsIndex--;\n      }\n    }\n\n    trimTrailingWhitespace(charsIndex, nextTag);\n  }\n\n  new HTMLParser(value, {\n    partialMarkup: partialMarkup,\n    html5: options.html5,\n    start: function start(tag, attrs, unary, unarySlash, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.create(options);\n        options.caseSensitive = true;\n        options.keepClosingSlash = true;\n        options.name = identity;\n      }\n\n      tag = options.name(tag);\n      currentTag = tag;\n      charsPrevTag = tag;\n\n      if (!inlineTextTags(tag)) {\n        currentChars = '';\n      }\n\n      hasChars = false;\n      currentAttrs = attrs;\n      var optional = options.removeOptionalTags;\n\n      if (optional) {\n        var htmlTag = htmlTags(tag); // <html> may be omitted if first thing inside is not comment\n        // <head> may be omitted if first thing inside is an element\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        // <colgroup> may be omitted if first thing inside is <col>\n        // <tbody> may be omitted if first thing inside is <tr>\n\n        if (htmlTag && canRemoveParentTag(optionalStartTag, tag)) {\n          removeStartTag();\n        }\n\n        optionalStartTag = ''; // end-tag-followed-by-start-tag omission rules\n\n        if (htmlTag && canRemovePrecedingTag(optionalEndTag, tag)) {\n          removeEndTag(); // <colgroup> cannot be omitted if preceding </colgroup> is omitted\n          // <tbody> cannot be omitted if preceding </tbody>, </thead> or </tfoot> is omitted\n\n          optional = !isStartTagMandatory(optionalEndTag, tag);\n        }\n\n        optionalEndTag = '';\n      } // set whitespace flags for nested tags (eg. <code> within a <pre>)\n\n\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          squashTrailingWhitespace(tag);\n        }\n\n        if (!unary) {\n          if (!_canTrimWhitespace(tag, attrs) || stackNoTrimWhitespace.length) {\n            stackNoTrimWhitespace.push(tag);\n          }\n\n          if (!_canCollapseWhitespace(tag, attrs) || stackNoCollapseWhitespace.length) {\n            stackNoCollapseWhitespace.push(tag);\n          }\n        }\n      }\n\n      var openTag = '<' + tag;\n      var hasUnarySlash = unarySlash && options.keepClosingSlash;\n      buffer.push(openTag);\n\n      if (options.sortAttributes) {\n        options.sortAttributes(tag, attrs);\n      }\n\n      var parts = [];\n\n      for (var i = attrs.length, isLast = true; --i >= 0;) {\n        var normalized = normalizeAttr(attrs[i], attrs, tag, options);\n\n        if (normalized) {\n          parts.unshift(buildAttr(normalized, hasUnarySlash, options, isLast, uidAttr));\n          isLast = false;\n        }\n      }\n\n      if (parts.length > 0) {\n        buffer.push(' ');\n        buffer.push.apply(buffer, parts);\n      } // start tag must never be omitted if it has any attributes\n      else if (optional && optionalStartTags(tag)) {\n          optionalStartTag = tag;\n        }\n\n      buffer.push(buffer.pop() + (hasUnarySlash ? '/' : '') + '>');\n\n      if (autoGenerated && !options.includeAutoGeneratedTags) {\n        removeStartTag();\n        optionalStartTag = '';\n      }\n    },\n    end: function end(tag, attrs, autoGenerated) {\n      if (tag.toLowerCase() === 'svg') {\n        options = Object.getPrototypeOf(options);\n      }\n\n      tag = options.name(tag); // check if current tag is in a whitespace stack\n\n      if (options.collapseWhitespace) {\n        if (stackNoTrimWhitespace.length) {\n          if (tag === stackNoTrimWhitespace[stackNoTrimWhitespace.length - 1]) {\n            stackNoTrimWhitespace.pop();\n          }\n        } else {\n          squashTrailingWhitespace('/' + tag);\n        }\n\n        if (stackNoCollapseWhitespace.length && tag === stackNoCollapseWhitespace[stackNoCollapseWhitespace.length - 1]) {\n          stackNoCollapseWhitespace.pop();\n        }\n      }\n\n      var isElementEmpty = false;\n\n      if (tag === currentTag) {\n        currentTag = '';\n        isElementEmpty = !hasChars;\n      }\n\n      if (options.removeOptionalTags) {\n        // <html>, <head> or <body> may be omitted if the element is empty\n        if (isElementEmpty && topLevelTags(optionalStartTag)) {\n          removeStartTag();\n        }\n\n        optionalStartTag = ''; // </html> or </body> may be omitted if not followed by comment\n        // </head> may be omitted if not followed by space or comment\n        // </p> may be omitted if no more content in non-</a> parent\n        // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n\n        if (htmlTags(tag) && optionalEndTag && !trailingTags(optionalEndTag) && (optionalEndTag !== 'p' || !pInlineTags(tag))) {\n          removeEndTag();\n        }\n\n        optionalEndTag = optionalEndTags(tag) ? tag : '';\n      }\n\n      if (options.removeEmptyElements && isElementEmpty && canRemoveElement(tag, attrs)) {\n        // remove last \"element\" from buffer\n        removeStartTag();\n        optionalStartTag = '';\n        optionalEndTag = '';\n      } else {\n        if (autoGenerated && !options.includeAutoGeneratedTags) {\n          optionalEndTag = '';\n        } else {\n          buffer.push('</' + tag + '>');\n        }\n\n        charsPrevTag = '/' + tag;\n\n        if (!inlineTags(tag)) {\n          currentChars = '';\n        } else if (isElementEmpty) {\n          currentChars += '|';\n        }\n      }\n    },\n    chars: function chars(text, prevTag, nextTag) {\n      prevTag = prevTag === '' ? 'comment' : prevTag;\n      nextTag = nextTag === '' ? 'comment' : nextTag;\n\n      if (options.decodeEntities && text && !specialContentTags(currentTag)) {\n        text = decode(text);\n      }\n\n      if (options.collapseWhitespace) {\n        if (!stackNoTrimWhitespace.length) {\n          if (prevTag === 'comment') {\n            var prevComment = buffer[buffer.length - 1];\n\n            if (prevComment.indexOf(uidIgnore) === -1) {\n              if (!prevComment) {\n                prevTag = charsPrevTag;\n              }\n\n              if (buffer.length > 1 && (!prevComment || !options.conservativeCollapse && / $/.test(currentChars))) {\n                var charsIndex = buffer.length - 2;\n                buffer[charsIndex] = buffer[charsIndex].replace(/\\s+$/, function (trailingSpaces) {\n                  text = trailingSpaces + text;\n                  return '';\n                });\n              }\n            }\n          }\n\n          if (prevTag) {\n            if (prevTag === '/nobr' || prevTag === 'wbr') {\n              if (/^\\s/.test(text)) {\n                var tagIndex = buffer.length - 1;\n\n                while (tagIndex > 0 && buffer[tagIndex].lastIndexOf('<' + prevTag) !== 0) {\n                  tagIndex--;\n                }\n\n                trimTrailingWhitespace(tagIndex - 1, 'br');\n              }\n            } else if (inlineTextTags(prevTag.charAt(0) === '/' ? prevTag.slice(1) : prevTag)) {\n              text = collapseWhitespace(text, options, /(?:^|\\s)$/.test(currentChars));\n            }\n          }\n\n          if (prevTag || nextTag) {\n            text = collapseWhitespaceSmart(text, prevTag, nextTag, options);\n          } else {\n            text = collapseWhitespace(text, options, true, true);\n          }\n\n          if (!text && /\\s$/.test(currentChars) && prevTag && prevTag.charAt(0) === '/') {\n            trimTrailingWhitespace(buffer.length - 1, nextTag);\n          }\n        }\n\n        if (!stackNoCollapseWhitespace.length && nextTag !== 'html' && !(prevTag && nextTag)) {\n          text = collapseWhitespace(text, options, false, false, true);\n        }\n      }\n\n      if (options.processScripts && specialContentTags(currentTag)) {\n        text = processScript(text, options, currentAttrs);\n      }\n\n      if (isExecutableScript(currentTag, currentAttrs)) {\n        text = options.minifyJS(text);\n      }\n\n      if (isStyleSheet(currentTag, currentAttrs)) {\n        text = options.minifyCSS(text);\n      }\n\n      if (options.removeOptionalTags && text) {\n        // <html> may be omitted if first thing inside is not comment\n        // <body> may be omitted if first thing inside is not space, comment, <meta>, <link>, <script>, <style> or <template>\n        if (optionalStartTag === 'html' || optionalStartTag === 'body' && !/^\\s/.test(text)) {\n          removeStartTag();\n        }\n\n        optionalStartTag = ''; // </html> or </body> may be omitted if not followed by comment\n        // </head>, </colgroup> or </caption> may be omitted if not followed by space or comment\n\n        if (compactTags(optionalEndTag) || looseTags(optionalEndTag) && !/^\\s/.test(text)) {\n          removeEndTag();\n        }\n\n        optionalEndTag = '';\n      }\n\n      charsPrevTag = /^\\s*$/.test(text) ? prevTag : 'comment';\n\n      if (options.decodeEntities && text && !specialContentTags(currentTag)) {\n        // Escape any `&` symbols that start either:\n        // 1) a legacy named character reference (i.e. one that doesn't end with `;`)\n        // 2) or any other character reference (i.e. one that does end with `;`)\n        // Note that `&` can be escaped as `&amp`, without the semi-colon.\n        // https://mathiasbynens.be/notes/ambiguous-ampersands\n        text = text.replace(/&((?:Iacute|aacute|uacute|plusmn|Otilde|otilde|agrave|Agrave|Yacute|yacute|Oslash|oslash|atilde|Atilde|brvbar|ccedil|Ccedil|Ograve|curren|divide|eacute|Eacute|ograve|Oacute|egrave|Egrave|Ugrave|frac12|frac14|frac34|ugrave|oacute|iacute|Ntilde|ntilde|Uacute|middot|igrave|Igrave|iquest|Aacute|cedil|laquo|micro|iexcl|Icirc|icirc|acirc|Ucirc|Ecirc|ocirc|Ocirc|ecirc|ucirc|Aring|aring|AElig|aelig|acute|pound|raquo|Acirc|times|THORN|szlig|thorn|COPY|auml|ordf|ordm|Uuml|macr|uuml|Auml|ouml|Ouml|para|nbsp|euml|quot|QUOT|Euml|yuml|cent|sect|copy|sup1|sup2|sup3|iuml|Iuml|ETH|shy|reg|not|yen|amp|AMP|REG|uml|eth|deg|gt|GT|LT|lt)(?!;)|(?:#?[0-9a-zA-Z]+;))/g, '&amp$1').replace(/</g, '&lt;');\n      }\n\n      if (uidPattern && options.collapseWhitespace && stackNoTrimWhitespace.length) {\n        text = text.replace(uidPattern, function (match, prefix, index) {\n          return ignoredCustomMarkupChunks[+index][0];\n        });\n      }\n\n      currentChars += text;\n\n      if (text) {\n        hasChars = true;\n      }\n\n      buffer.push(text);\n    },\n    comment: function comment(text, nonStandard) {\n      var prefix = nonStandard ? '<!' : '<!--';\n      var suffix = nonStandard ? '>' : '-->';\n\n      if (isConditionalComment(text)) {\n        text = prefix + cleanConditionalComment(text, options) + suffix;\n      } else if (options.removeComments) {\n        if (isIgnoredComment(text, options)) {\n          text = '<!--' + text + '-->';\n        } else {\n          text = '';\n        }\n      } else {\n        text = prefix + text + suffix;\n      }\n\n      if (options.removeOptionalTags && text) {\n        // preceding comments suppress tag omissions\n        optionalStartTag = '';\n        optionalEndTag = '';\n      }\n\n      buffer.push(text);\n    },\n    doctype: function doctype(_doctype) {\n      buffer.push(options.useShortDoctype ? '<!doctype' + (options.removeTagWhitespace ? '' : ' ') + 'html>' : collapseWhitespaceAll(_doctype));\n    },\n    customAttrAssign: options.customAttrAssign,\n    customAttrSurround: options.customAttrSurround\n  });\n\n  if (options.removeOptionalTags) {\n    // <html> may be omitted if first thing inside is not comment\n    // <head> or <body> may be omitted if empty\n    if (topLevelTags(optionalStartTag)) {\n      removeStartTag();\n    } // except for </dt> or </thead>, end tags may be omitted if no more content in parent element\n\n\n    if (optionalEndTag && !trailingTags(optionalEndTag)) {\n      removeEndTag();\n    }\n  }\n\n  if (options.collapseWhitespace) {\n    squashTrailingWhitespace('br');\n  }\n\n  return joinResultSegments(buffer, options, uidPattern ? function (str) {\n    return str.replace(uidPattern, function (match, prefix, index, suffix) {\n      var chunk = ignoredCustomMarkupChunks[+index][0];\n\n      if (options.collapseWhitespace) {\n        if (prefix !== '\\t') {\n          chunk = prefix + chunk;\n        }\n\n        if (suffix !== '\\t') {\n          chunk += suffix;\n        }\n\n        return collapseWhitespace(chunk, {\n          preserveLineBreaks: options.preserveLineBreaks,\n          conservativeCollapse: !options.trimCustomFragments\n        }, /^[ \\n\\r\\t\\f]/.test(chunk), /[ \\n\\r\\t\\f]$/.test(chunk));\n      }\n\n      return chunk;\n    });\n  } : identity, uidIgnore ? function (str) {\n    return str.replace(new RegExp('<!--' + uidIgnore + '([0-9]+)-->', 'g'), function (match, index) {\n      return ignoredMarkupChunks[+index];\n    });\n  } : identity);\n}\n\nfunction joinResultSegments(results, options, restoreCustom, restoreIgnore) {\n  var str;\n  var maxLineLength = options.maxLineLength;\n\n  if (maxLineLength) {\n    var line = '',\n        lines = [];\n\n    while (results.length) {\n      var len = line.length;\n      var end = results[0].indexOf('\\n');\n\n      if (end < 0) {\n        line += restoreIgnore(restoreCustom(results.shift()));\n      } else {\n        line += restoreIgnore(restoreCustom(results[0].slice(0, end)));\n        results[0] = results[0].slice(end + 1);\n      }\n\n      if (len > 0 && line.length > maxLineLength) {\n        lines.push(line.slice(0, len));\n        line = line.slice(len);\n      } else if (end >= 0) {\n        lines.push(line);\n        line = '';\n      }\n    }\n\n    if (line) {\n      lines.push(line);\n    }\n\n    str = lines.join('\\n');\n  } else {\n    str = restoreIgnore(restoreCustom(results.join('')));\n  }\n\n  return options.collapseWhitespace ? collapseWhitespace(str, options, true, true) : str;\n}\n\nexports.minify = function (value, options) {\n  var start = Date.now();\n  options = processOptions(options || {});\n  var result = minify(value, options);\n  options.log('minified in: ' + (Date.now() - start) + 'ms');\n  return result;\n};","map":null,"metadata":{},"sourceType":"script"}