{"ast":null,"code":"/*\n * This file uses webpack to compile a template with a child compiler.\n *\n * [TEMPLATE] -> [JAVASCRIPT]\n *\n */\n'use strict';\n\nvar path = require('path');\n\nvar NodeTemplatePlugin = require('webpack/lib/node/NodeTemplatePlugin');\n\nvar NodeTargetPlugin = require('webpack/lib/node/NodeTargetPlugin');\n\nvar LoaderTargetPlugin = require('webpack/lib/LoaderTargetPlugin');\n\nvar LibraryTemplatePlugin = require('webpack/lib/LibraryTemplatePlugin');\n\nvar SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');\n/**\n * Compiles the template into a nodejs factory, adds its to the compilation.assets\n * and returns a promise of the result asset object.\n *\n * @param template relative path to the template file\n * @param context path context\n * @param outputFilename the file name\n * @param compilation The webpack compilation object\n *\n * Returns an object:\n * {\n *  hash: {String} - Base64 hash of the file\n *  content: {String} - Javascript executable code of the template\n * }\n *\n */\n\n\nmodule.exports.compileTemplate = function compileTemplate(template, context, outputFilename, compilation) {\n  // The entry file is just an empty helper as the dynamic template\n  // require is added in \"loader.js\"\n  var outputOptions = {\n    filename: outputFilename,\n    publicPath: compilation.outputOptions.publicPath\n  }; // Store the result of the parent compilation before we start the child compilation\n\n  var assetsBeforeCompilation = Object.assign({}, compilation.assets[outputOptions.filename]); // Create an additional child compiler which takes the template\n  // and turns it into an Node.JS html factory.\n  // This allows us to use loaders during the compilation\n\n  var compilerName = getCompilerName(context, outputFilename);\n  var childCompiler = compilation.createChildCompiler(compilerName, outputOptions);\n  childCompiler.context = context;\n  new NodeTemplatePlugin(outputOptions).apply(childCompiler);\n  new NodeTargetPlugin().apply(childCompiler);\n  new LibraryTemplatePlugin('HTML_WEBPACK_PLUGIN_RESULT', 'var').apply(childCompiler); // Using undefined as name for the SingleEntryPlugin causes a unexpected output as described in\n  // https://github.com/jantimon/html-webpack-plugin/issues/895\n  // Using a string as a name for the SingleEntryPlugin causes problems with HMR as described in\n  // https://github.com/jantimon/html-webpack-plugin/issues/900\n  // Until the HMR issue is fixed we keep the ugly output:\n\n  new SingleEntryPlugin(this.context, template, undefined).apply(childCompiler);\n  new LoaderTargetPlugin('node').apply(childCompiler); // Fix for \"Uncaught TypeError: __webpack_require__(...) is not a function\"\n  // Hot module replacement requires that every child compiler has its own\n  // cache. @see https://github.com/ampedandwired/html-webpack-plugin/pull/179\n  // Backwards compatible version of: childCompiler.hooks.compilation\n\n  (childCompiler.hooks ? childCompiler.hooks.compilation.tap.bind(childCompiler.hooks.compilation, 'HtmlWebpackPlugin') : childCompiler.plugin.bind(childCompiler, 'compilation'))(function (compilation) {\n    if (compilation.cache) {\n      if (!compilation.cache[compilerName]) {\n        compilation.cache[compilerName] = {};\n      }\n\n      compilation.cache = compilation.cache[compilerName];\n    }\n  }); // Compile and return a promise\n\n  return new Promise(function (resolve, reject) {\n    childCompiler.runAsChild(function (err, entries, childCompilation) {\n      // Resolve / reject the promise\n      if (childCompilation && childCompilation.errors && childCompilation.errors.length) {\n        var errorDetails = childCompilation.errors.map(function (error) {\n          return error.message + (error.error ? ':\\n' + error.error : '');\n        }).join('\\n');\n        reject(new Error('Child compilation failed:\\n' + errorDetails));\n      } else if (err) {\n        reject(err);\n      } else {\n        // Replace [hash] placeholders in filename\n        // In webpack 4 the plugin interface changed, so check for available fns\n        var outputName = compilation.mainTemplate.getAssetPath ? compilation.mainTemplate.hooks.assetPath.call(outputOptions.filename, {\n          hash: childCompilation.hash,\n          chunk: entries[0]\n        }) : compilation.mainTemplate.applyPluginsWaterfall('asset-path', outputOptions.filename, {\n          hash: childCompilation.hash,\n          chunk: entries[0]\n        }); // Restore the parent compilation to the state like it\n        // was before the child compilation\n\n        compilation.assets[outputName] = assetsBeforeCompilation[outputName];\n\n        if (assetsBeforeCompilation[outputName] === undefined) {\n          // If it wasn't there - delete it\n          delete compilation.assets[outputName];\n        }\n\n        resolve({\n          // Hash of the template entry point\n          hash: entries[0].hash,\n          // Output name\n          outputName: outputName,\n          // Compiled code\n          content: childCompilation.assets[outputName].source()\n        });\n      }\n    });\n  });\n};\n/**\n * Returns the child compiler name e.g. 'html-webpack-plugin for \"index.html\"'\n */\n\n\nfunction getCompilerName(context, filename) {\n  var absolutePath = path.resolve(context, filename);\n  var relativePath = path.relative(context, absolutePath);\n  return 'html-webpack-plugin for \"' + (absolutePath.length < relativePath.length ? absolutePath : relativePath) + '\"';\n}","map":null,"metadata":{},"sourceType":"script"}