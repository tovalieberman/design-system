{"ast":null,"code":"'use strict';\n\nvar _get = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _classCallCheck = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar assert = require('assert');\n\nvar Buffer = require('buffer').Buffer;\n\nvar realZlib = require('zlib');\n\nvar constants = exports.constants = require('./constants.js');\n\nvar MiniPass = require('minipass');\n\nvar OriginalBufferConcat = Buffer.concat;\n\nvar ZlibError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(ZlibError, _Error);\n\n  function ZlibError(msg, errno) {\n    var _this;\n\n    _classCallCheck(this, ZlibError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ZlibError).call(this, 'zlib: ' + msg));\n    _this.errno = errno;\n    _this.code = codes.get(errno);\n    return _this;\n  }\n\n  _createClass(ZlibError, [{\n    key: \"name\",\n    get: function get() {\n      return 'ZlibError';\n    }\n  }]);\n\n  return ZlibError;\n}(_wrapNativeSuper(Error)); // translation table for return codes.\n\n\nvar codes = new Map([[constants.Z_OK, 'Z_OK'], [constants.Z_STREAM_END, 'Z_STREAM_END'], [constants.Z_NEED_DICT, 'Z_NEED_DICT'], [constants.Z_ERRNO, 'Z_ERRNO'], [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'], [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'], [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'], [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'], [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']]);\nvar validFlushFlags = new Set([constants.Z_NO_FLUSH, constants.Z_PARTIAL_FLUSH, constants.Z_SYNC_FLUSH, constants.Z_FULL_FLUSH, constants.Z_FINISH, constants.Z_BLOCK]);\nvar strategies = new Set([constants.Z_FILTERED, constants.Z_HUFFMAN_ONLY, constants.Z_RLE, constants.Z_FIXED, constants.Z_DEFAULT_STRATEGY]); // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nvar _opts = Symbol('opts');\n\nvar _flushFlag = Symbol('flushFlag');\n\nvar _finishFlush = Symbol('finishFlush');\n\nvar _handle = Symbol('handle');\n\nvar _onError = Symbol('onError');\n\nvar _level = Symbol('level');\n\nvar _strategy = Symbol('strategy');\n\nvar _ended = Symbol('ended');\n\nvar Zlib =\n/*#__PURE__*/\nfunction (_MiniPass) {\n  _inherits(Zlib, _MiniPass);\n\n  function Zlib(opts, mode) {\n    var _this2;\n\n    _classCallCheck(this, Zlib);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Zlib).call(this, opts));\n    _this2[_ended] = false;\n    _this2[_opts] = opts = opts || {};\n\n    if (opts.flush && !validFlushFlags.has(opts.flush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.flush);\n    }\n\n    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {\n      throw new TypeError('Invalid flush flag: ' + opts.finishFlush);\n    }\n\n    _this2[_flushFlag] = opts.flush || constants.Z_NO_FLUSH;\n    _this2[_finishFlush] = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : constants.Z_FINISH;\n\n    if (opts.chunkSize) {\n      if (opts.chunkSize < constants.Z_MIN_CHUNK) {\n        throw new RangeError('Invalid chunk size: ' + opts.chunkSize);\n      }\n    }\n\n    if (opts.windowBits) {\n      if (opts.windowBits < constants.Z_MIN_WINDOWBITS || opts.windowBits > constants.Z_MAX_WINDOWBITS) {\n        throw new RangeError('Invalid windowBits: ' + opts.windowBits);\n      }\n    }\n\n    if (opts.level) {\n      if (opts.level < constants.Z_MIN_LEVEL || opts.level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + opts.level);\n      }\n    }\n\n    if (opts.memLevel) {\n      if (opts.memLevel < constants.Z_MIN_MEMLEVEL || opts.memLevel > constants.Z_MAX_MEMLEVEL) {\n        throw new RangeError('Invalid memLevel: ' + opts.memLevel);\n      }\n    }\n\n    if (opts.strategy && !strategies.has(opts.strategy)) throw new TypeError('Invalid strategy: ' + opts.strategy);\n\n    if (opts.dictionary) {\n      if (!(opts.dictionary instanceof Buffer)) {\n        throw new TypeError('Invalid dictionary: it should be a Buffer instance');\n      }\n    }\n\n    _this2[_handle] = new realZlib[mode](opts);\n\n    _this2[_onError] = function (err) {\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      _this2.close();\n\n      var error = new ZlibError(err.message, err.errno);\n\n      _this2.emit('error', error);\n    };\n\n    _this2[_handle].on('error', _this2[_onError]);\n\n    var level = typeof opts.level === 'number' ? opts.level : constants.Z_DEFAULT_COMPRESSION;\n    var strategy = typeof opts.strategy === 'number' ? opts.strategy : constants.Z_DEFAULT_STRATEGY; // API changed in node v9\n\n    /* istanbul ignore next */\n\n    _this2[_level] = level;\n    _this2[_strategy] = strategy;\n\n    _this2.once('end', _this2.close);\n\n    return _this2;\n  }\n\n  _createClass(Zlib, [{\n    key: \"close\",\n    value: function close() {\n      if (this[_handle]) {\n        this[_handle].close();\n\n        this[_handle] = null;\n        this.emit('close');\n      }\n    }\n  }, {\n    key: \"params\",\n    value: function params(level, strategy) {\n      var _this3 = this;\n\n      if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all\n\n      /* istanbul ignore if */\n\n      if (!this[_handle].params) throw new Error('not supported in this implementation');\n\n      if (level < constants.Z_MIN_LEVEL || level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + level);\n      }\n\n      if (!strategies.has(strategy)) throw new TypeError('Invalid strategy: ' + strategy);\n\n      if (this[_level] !== level || this[_strategy] !== strategy) {\n        this.flush(constants.Z_SYNC_FLUSH);\n        assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the\n        // core zlib. We override .flush() temporarily to intercept that and\n        // flush synchronously.\n\n        var origFlush = this[_handle].flush;\n\n        this[_handle].flush = function (flushFlag, cb) {\n          _this3[_handle].flush = origFlush;\n\n          _this3.flush(flushFlag);\n\n          cb();\n        };\n\n        this[_handle].params(level, strategy);\n        /* istanbul ignore else */\n\n\n        if (this[_handle]) {\n          this[_level] = level;\n          this[_strategy] = strategy;\n        }\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      assert(this[_handle], 'zlib binding closed');\n      return this[_handle].reset();\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(kind) {\n      if (kind === undefined) kind = constants.Z_FULL_FLUSH;\n      if (this.ended) return;\n      var flushFlag = this[_flushFlag];\n      this[_flushFlag] = kind;\n      this.write(Buffer.alloc(0));\n      this[_flushFlag] = flushFlag;\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (chunk) this.write(chunk, encoding);\n      this.flush(this[_finishFlush]);\n      this[_ended] = true;\n      return _get(_getPrototypeOf(Zlib.prototype), \"end\", this).call(this, null, null, cb);\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      // process the chunk using the sync process\n      // then super.write() all the outputted chunks\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n      assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we\n      // intercept that by temporarily making it a no-op.\n\n      var nativeHandle = this[_handle]._handle;\n      var originalNativeClose = nativeHandle.close;\n\n      nativeHandle.close = function () {};\n\n      var originalClose = this[_handle].close;\n\n      this[_handle].close = function () {}; // It also calls `Buffer.concat()` at the end, which may be convenient\n      // for some, but which we are not interested in as it slows us down.\n\n\n      Buffer.concat = function (args) {\n        return args;\n      };\n\n      var result;\n\n      try {\n        result = this[_handle]._processChunk(chunk, this[_flushFlag]);\n      } catch (err) {\n        this[_onError](err);\n      } finally {\n        Buffer.concat = OriginalBufferConcat;\n\n        if (this[_handle]) {\n          // Core zlib resets `_handle` to null after attempting to close the\n          // native handle. Our no-op handler prevented actual closure, but we\n          // need to restore the `._handle` property.\n          this[_handle]._handle = nativeHandle;\n          nativeHandle.close = originalNativeClose;\n          this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it\n          // after each call, these handlers start piling up.\n\n          this[_handle].removeAllListeners('error');\n        }\n      }\n\n      var writeReturn;\n\n      if (result) {\n        if (Array.isArray(result) && result.length > 0) {\n          // The first buffer is always `handle._outBuffer`, which would be\n          // re-used for later invocations; so, we always have to copy that one.\n          writeReturn = _get(_getPrototypeOf(Zlib.prototype), \"write\", this).call(this, Buffer.from(result[0]));\n\n          for (var i = 1; i < result.length; i++) {\n            writeReturn = _get(_getPrototypeOf(Zlib.prototype), \"write\", this).call(this, result[i]);\n          }\n        } else {\n          writeReturn = _get(_getPrototypeOf(Zlib.prototype), \"write\", this).call(this, Buffer.from(result));\n        }\n      }\n\n      if (cb) cb();\n      return writeReturn;\n    }\n  }, {\n    key: \"ended\",\n    get: function get() {\n      return this[_ended];\n    }\n  }]);\n\n  return Zlib;\n}(MiniPass); // minimal 2-byte header\n\n\nvar Deflate =\n/*#__PURE__*/\nfunction (_Zlib) {\n  _inherits(Deflate, _Zlib);\n\n  function Deflate(opts) {\n    _classCallCheck(this, Deflate);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Deflate).call(this, opts, 'Deflate'));\n  }\n\n  return Deflate;\n}(Zlib);\n\nvar Inflate =\n/*#__PURE__*/\nfunction (_Zlib2) {\n  _inherits(Inflate, _Zlib2);\n\n  function Inflate(opts) {\n    _classCallCheck(this, Inflate);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Inflate).call(this, opts, 'Inflate'));\n  }\n\n  return Inflate;\n}(Zlib); // gzip - bigger header, same deflate compression\n\n\nvar Gzip =\n/*#__PURE__*/\nfunction (_Zlib3) {\n  _inherits(Gzip, _Zlib3);\n\n  function Gzip(opts) {\n    _classCallCheck(this, Gzip);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Gzip).call(this, opts, 'Gzip'));\n  }\n\n  return Gzip;\n}(Zlib);\n\nvar Gunzip =\n/*#__PURE__*/\nfunction (_Zlib4) {\n  _inherits(Gunzip, _Zlib4);\n\n  function Gunzip(opts) {\n    _classCallCheck(this, Gunzip);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Gunzip).call(this, opts, 'Gunzip'));\n  }\n\n  return Gunzip;\n}(Zlib); // raw - no header\n\n\nvar DeflateRaw =\n/*#__PURE__*/\nfunction (_Zlib5) {\n  _inherits(DeflateRaw, _Zlib5);\n\n  function DeflateRaw(opts) {\n    _classCallCheck(this, DeflateRaw);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateRaw).call(this, opts, 'DeflateRaw'));\n  }\n\n  return DeflateRaw;\n}(Zlib);\n\nvar InflateRaw =\n/*#__PURE__*/\nfunction (_Zlib6) {\n  _inherits(InflateRaw, _Zlib6);\n\n  function InflateRaw(opts) {\n    _classCallCheck(this, InflateRaw);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(InflateRaw).call(this, opts, 'InflateRaw'));\n  }\n\n  return InflateRaw;\n}(Zlib); // auto-detect header.\n\n\nvar Unzip =\n/*#__PURE__*/\nfunction (_Zlib7) {\n  _inherits(Unzip, _Zlib7);\n\n  function Unzip(opts) {\n    _classCallCheck(this, Unzip);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Unzip).call(this, opts, 'Unzip'));\n  }\n\n  return Unzip;\n}(Zlib);\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;","map":null,"metadata":{},"sourceType":"script"}