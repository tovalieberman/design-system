{"ast":null,"code":"// Generated by CoffeeScript 1.8.0\nvar ParsedError, prop, sysPath, _fn, _i, _len, _ref;\n\nsysPath = require('path');\n\nmodule.exports = ParsedError = function () {\n  function ParsedError(error) {\n    this.error = error;\n\n    this._parse();\n  }\n\n  ParsedError.prototype._parse = function () {\n    var m;\n    this._trace = [];\n    this._kind = 'Error';\n    this._wrapper = '';\n\n    if (this.error.wrapper != null) {\n      this._wrapper = String(this.error.wrapper);\n    }\n\n    if (typeof this.error !== 'object') {\n      this._message = String(this.error);\n    } else {\n      this._stack = this.error.stack;\n\n      if (this.error.kind != null) {\n        this._kind = String(this.error.kind);\n      } else if (typeof this._stack === 'string') {\n        if (m = this._stack.match(/^([a-zA-Z0-9\\_\\$]+):\\ /)) {\n          this._kind = m[1];\n        }\n      }\n\n      if (typeof this._stack === 'string') {\n        this._parseStack();\n      } else {\n        this._message = this.error.message != null && String(this.error.message) || '';\n      }\n    }\n  };\n\n  ParsedError.prototype._parseStack = function () {\n    var line, message, messageLines, reachedTrace, _i, _len, _ref;\n\n    messageLines = [];\n    reachedTrace = false;\n    _ref = this._stack.split('\\n');\n\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      line = _ref[_i];\n\n      if (line.trim() === '') {\n        continue;\n      }\n\n      if (reachedTrace) {\n        this._trace.push(this._parseTraceItem(line));\n      } else {\n        if (line.match(/^\\s*at\\s.+/)) {\n          reachedTrace = true;\n\n          this._trace.push(this._parseTraceItem(line));\n        } else {\n          messageLines.push(line);\n        }\n      }\n    }\n\n    message = messageLines.join('\\n');\n\n    if (message.substr(0, this._kind.length) === this._kind) {\n      message = message.substr(this._kind.length, message.length).replace(/^\\:\\s+/, '');\n    }\n\n    this._message = message;\n  };\n\n  ParsedError.prototype._parseTraceItem = function (text) {\n    var addr, col, d, dir, file, jsCol, jsLine, line, m, original, packageName, packages, path, r, remaining, shortenedAddr, shortenedPath, what;\n    text = text.trim();\n\n    if (text === '') {\n      return;\n    }\n\n    if (!text.match(/^at\\ /)) {\n      return text;\n    }\n\n    text = text.replace(/^at /, '');\n\n    if (text === 'Error (<anonymous>)' || text === 'Error (<anonymous>:null:null)') {\n      return;\n    }\n\n    original = text;\n    what = null;\n    addr = null;\n    path = null;\n    dir = null;\n    file = null;\n    line = null;\n    col = null;\n    jsLine = null;\n    jsCol = null;\n    shortenedPath = null;\n    shortenedAddr = null;\n    packageName = '[current]';\n\n    if (m = text.match(/\\(([^\\)]+)\\)$/)) {\n      addr = m[1].trim();\n    }\n\n    if (addr != null) {\n      what = text.substr(0, text.length - addr.length - 2);\n      what = what.trim();\n    }\n\n    if (addr == null) {\n      addr = text.trim();\n    }\n\n    addr = this._fixPath(addr);\n    remaining = addr;\n\n    if (m = remaining.match(/\\,\\ <js>:(\\d+):(\\d+)$/)) {\n      jsLine = m[1];\n      jsCol = m[2];\n      remaining = remaining.substr(0, remaining.length - m[0].length);\n    }\n\n    if (m = remaining.match(/:(\\d+):(\\d+)$/)) {\n      line = m[1];\n      col = m[2];\n      remaining = remaining.substr(0, remaining.length - m[0].length);\n      path = remaining;\n    }\n\n    if (path != null) {\n      file = sysPath.basename(path);\n      dir = sysPath.dirname(path);\n\n      if (dir === '.') {\n        dir = '';\n      }\n\n      path = this._fixPath(path);\n      file = this._fixPath(file);\n      dir = this._fixPath(dir);\n    }\n\n    if (dir != null) {\n      d = dir.replace(/[\\\\]{1,2}/g, '/');\n\n      if (m = d.match(/node_modules\\/([^\\/]+)(?!.*node_modules.*)/)) {\n        packageName = m[1];\n      }\n    }\n\n    if (jsLine == null) {\n      jsLine = line;\n      jsCol = col;\n    }\n\n    if (path != null) {\n      r = this._rectifyPath(path);\n      shortenedPath = r.path;\n      shortenedAddr = shortenedPath + addr.substr(path.length, addr.length);\n      packages = r.packages;\n    }\n\n    return {\n      original: original,\n      what: what,\n      addr: addr,\n      path: path,\n      dir: dir,\n      file: file,\n      line: parseInt(line),\n      col: parseInt(col),\n      jsLine: parseInt(jsLine),\n      jsCol: parseInt(jsCol),\n      packageName: packageName,\n      shortenedPath: shortenedPath,\n      shortenedAddr: shortenedAddr,\n      packages: packages || []\n    };\n  };\n\n  ParsedError.prototype._getMessage = function () {\n    return this._message;\n  };\n\n  ParsedError.prototype._getKind = function () {\n    return this._kind;\n  };\n\n  ParsedError.prototype._getWrapper = function () {\n    return this._wrapper;\n  };\n\n  ParsedError.prototype._getStack = function () {\n    return this._stack;\n  };\n\n  ParsedError.prototype._getArguments = function () {\n    return this.error[\"arguments\"];\n  };\n\n  ParsedError.prototype._getType = function () {\n    return this.error.type;\n  };\n\n  ParsedError.prototype._getTrace = function () {\n    return this._trace;\n  };\n\n  ParsedError.prototype._fixPath = function (path) {\n    return path.replace(/[\\\\]{1,2}/g, '/');\n  };\n\n  ParsedError.prototype._rectifyPath = function (path, nameForCurrentPackage) {\n    var m, packages, parts, remaining, rest;\n    path = String(path);\n    remaining = path;\n\n    if (!(m = path.match(/^(.+?)\\/node_modules\\/(.+)$/))) {\n      return {\n        path: path,\n        packages: []\n      };\n    }\n\n    parts = [];\n    packages = [];\n\n    if (typeof nameForCurrentPackage === 'string') {\n      parts.push(\"[\" + nameForCurrentPackage + \"]\");\n      packages.push(\"[\" + nameForCurrentPackage + \"]\");\n    } else {\n      parts.push(\"[\" + m[1].match(/([^\\/]+)$/)[1] + \"]\");\n      packages.push(m[1].match(/([^\\/]+)$/)[1]);\n    }\n\n    rest = m[2];\n\n    while (m = rest.match(/([^\\/]+)\\/node_modules\\/(.+)$/)) {\n      parts.push(\"[\" + m[1] + \"]\");\n      packages.push(m[1]);\n      rest = m[2];\n    }\n\n    if (m = rest.match(/([^\\/]+)\\/(.+)$/)) {\n      parts.push(\"[\" + m[1] + \"]\");\n      packages.push(m[1]);\n      rest = m[2];\n    }\n\n    parts.push(rest);\n    return {\n      path: parts.join(\"/\"),\n      packages: packages\n    };\n  };\n\n  return ParsedError;\n}();\n\n_ref = ['message', 'kind', 'arguments', 'type', 'stack', 'trace', 'wrapper'];\n\n_fn = function _fn() {\n  var methodName;\n  methodName = '_get' + prop[0].toUpperCase() + prop.substr(1, prop.length);\n  return Object.defineProperty(ParsedError.prototype, prop, {\n    get: function get() {\n      return this[methodName]();\n    }\n  });\n};\n\nfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n  prop = _ref[_i];\n\n  _fn();\n}","map":null,"metadata":{},"sourceType":"script"}