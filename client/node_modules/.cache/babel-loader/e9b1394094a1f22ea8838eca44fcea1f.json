{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar stringify_1 = require(\"./stringify\");\n\nvar quote_1 = require(\"./quote\");\n/**\n * Root path node.\n */\n\n\nvar ROOT_SENTINEL = Symbol(\"root\");\n/**\n * Stringify any JavaScript value.\n */\n\nfunction stringify(value, replacer, indent) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  var path = [];\n  var stack = new Set();\n  var tracking = new Map();\n  var unpack = new Map();\n  var valueCount = 0;\n  var _options$maxDepth = options.maxDepth,\n      maxDepth = _options$maxDepth === void 0 ? 100 : _options$maxDepth,\n      _options$references = options.references,\n      references = _options$references === void 0 ? false : _options$references,\n      _options$skipUndefine = options.skipUndefinedProperties,\n      skipUndefinedProperties = _options$skipUndefine === void 0 ? false : _options$skipUndefine,\n      _options$maxValues = options.maxValues,\n      maxValues = _options$maxValues === void 0 ? 100000 : _options$maxValues; // Wrap replacer function to support falling back on supported stringify.\n\n  var valueToString = replacerToString(replacer); // Every time you call `next(value)` execute this function.\n\n  var onNext = function onNext(value, key) {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return; // An undefined key is treated as an out-of-band \"value\".\n\n    if (key === undefined) return valueToString(value, space, onNext, key);\n    path.push(key);\n    var result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  var builder = references ? function (value, key) {\n    if (value !== null && (typeof value === \"object\" || typeof value === \"function\" || typeof value === \"symbol\")) {\n      // Track nodes to restore later.\n      if (tracking.has(value)) {\n        unpack.set(path.slice(1), tracking.get(value));\n        return; // Avoid serializing referenced nodes on an expression.\n      } // Track encountered nodes.\n\n\n      tracking.set(value, path.slice(1));\n    }\n\n    return valueToString(value, space, onNext, key);\n  } : function (value, key) {\n    // Stop on recursion.\n    if (stack.has(value)) return;\n    stack.add(value);\n    var result = valueToString(value, space, onNext, key);\n    stack.delete(value);\n    return result;\n  };\n  var result = onNext(value, ROOT_SENTINEL); // Attempt to restore circular references.\n\n  if (unpack.size) {\n    var sp = space ? \" \" : \"\";\n    var eol = space ? \"\\n\" : \"\";\n    var wrapper = \"var x\".concat(sp, \"=\").concat(sp).concat(result, \";\").concat(eol);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = unpack.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref3 = _step.value;\n\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var key = _ref2[0];\n        var _value = _ref2[1];\n        var keyPath = quote_1.stringifyPath(key, onNext);\n        var valuePath = quote_1.stringifyPath(_value, onNext);\n        wrapper += \"x\".concat(keyPath).concat(sp, \"=\").concat(sp, \"x\").concat(valuePath, \";\").concat(eol);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return \"(function\".concat(sp, \"()\").concat(sp, \"{\").concat(eol).concat(wrapper, \"return x;\").concat(eol, \"}())\");\n  }\n\n  return result;\n}\n\nexports.stringify = stringify;\n/**\n * Create `toString()` function from replacer.\n */\n\nfunction replacerToString(replacer) {\n  if (!replacer) return stringify_1.toString;\n  return function (value, space, next, key) {\n    return replacer(value, space, function (value) {\n      return stringify_1.toString(value, space, next, key);\n    }, key);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}