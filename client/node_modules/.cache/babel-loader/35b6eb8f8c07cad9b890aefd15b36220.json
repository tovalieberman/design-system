{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar quote_1 = require(\"./quote\");\n/**\n * Used in function stringification.\n */\n\n/* istanbul ignore next */\n\n\nvar METHOD_NAMES_ARE_QUOTED = {\n  \" \": function _() {\n    /* Empty. */\n  }\n}[\" \"].toString().charAt(0) === '\"';\nvar FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \"\n};\nvar METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\"\n};\nvar TOKENS_PRECEDING_REGEXPS = new Set((\"case delete else in instanceof new return throw typeof void \" + \", ; : + - ! ~ & | ^ * / % < > ? =\").split(\" \"));\n/**\n * Track function parser usage.\n */\n\nexports.USED_METHOD_KEY = new WeakSet();\n/**\n * Stringify a function.\n */\n\nexports.functionToString = function (fn, space, next, key) {\n  var name = typeof key === \"string\" ? key : undefined; // Track in function parser for object stringify to avoid duplicate output.\n\n  if (name !== undefined) exports.USED_METHOD_KEY.add(fn);\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\n\n\nfunction dedentFunction(fnString) {\n  var found;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = fnString.split(\"\\n\").slice(1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var line = _step.value;\n      var m = /^[\\s\\t]+/.exec(line);\n      if (!m) return fnString; // Early exit without indent.\n\n      var _m = _slicedToArray(m, 1),\n          str = _m[0];\n\n      if (found === undefined) found = str;else if (str.length < found.length) found = str;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return found ? fnString.split(\"\\n\".concat(found)).join(\"\\n\") : fnString;\n}\n\nexports.dedentFunction = dedentFunction;\n/**\n * Function parser and stringify.\n */\n\nvar FunctionParser =\n/*#__PURE__*/\nfunction () {\n  function FunctionParser(fn, indent, next, key) {\n    _classCallCheck(this, FunctionParser);\n\n    this.fn = fn;\n    this.indent = indent;\n    this.next = next;\n    this.key = key;\n    this.pos = 0;\n    this.hadKeyword = false;\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name;\n    this.keyQuote = key === undefined ? \"\" : quote_1.quoteKey(key, next);\n    this.keyPrefix = key === undefined ? \"\" : \"\".concat(this.keyQuote, \":\").concat(indent ? \" \" : \"\");\n    this.isMethodCandidate = key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  _createClass(FunctionParser, [{\n    key: \"stringify\",\n    value: function stringify() {\n      var value = this.tryParse(); // If we can't stringify this function, return a void expression; for\n      // bonus help with debugging, include the function as a string literal.\n\n      if (!value) {\n        return \"\".concat(this.keyPrefix, \"void \").concat(this.next(this.fnString));\n      }\n\n      return dedentFunction(value);\n    }\n  }, {\n    key: \"getPrefix\",\n    value: function getPrefix() {\n      if (this.isMethodCandidate && !this.hadKeyword) {\n        return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n      }\n\n      return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n    }\n  }, {\n    key: \"tryParse\",\n    value: function tryParse() {\n      if (this.fnString[this.fnString.length - 1] !== \"}\") {\n        // Must be an arrow function.\n        return this.keyPrefix + this.fnString;\n      } // Attempt to remove function prefix.\n\n\n      if (this.fn.name) {\n        var result = this.tryStrippingName();\n        if (result) return result;\n      } // Support class expressions.\n\n\n      var prevPos = this.pos;\n      if (this.consumeSyntax() === \"class\") return this.fnString;\n      this.pos = prevPos;\n\n      if (this.tryParsePrefixTokens()) {\n        var _result = this.tryStrippingName();\n\n        if (_result) return _result;\n        var offset = this.pos;\n\n        switch (this.consumeSyntax(\"WORD_LIKE\")) {\n          case \"WORD_LIKE\":\n            if (this.isMethodCandidate && !this.hadKeyword) {\n              offset = this.pos;\n            }\n\n          // tslint:disable-next-line no-switch-case-fall-through\n\n          case \"()\":\n            if (this.fnString.substr(this.pos, 2) === \"=>\") {\n              return this.keyPrefix + this.fnString;\n            }\n\n            this.pos = offset;\n          // tslint:disable-next-line no-switch-case-fall-through\n\n          case '\"':\n          case \"'\":\n          case \"[]\":\n            return this.getPrefix() + this.fnString.substr(this.pos);\n        }\n      }\n    }\n    /**\n     * Attempt to parse the function from the current position by first stripping\n     * the function's name from the front. This is not a fool-proof method on all\n     * JavaScript engines, but yields good results on Node.js 4 (and slightly\n     * less good results on Node.js 6 and 8).\n     */\n\n  }, {\n    key: \"tryStrippingName\",\n    value: function tryStrippingName() {\n      if (METHOD_NAMES_ARE_QUOTED) {\n        // ... then this approach is unnecessary and yields false positives.\n        return;\n      }\n\n      var start = this.pos;\n      var prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n      if (prefix === this.fn.name) {\n        this.pos += prefix.length;\n\n        if (this.consumeSyntax() === \"()\" && this.consumeSyntax() === \"{}\" && this.pos === this.fnString.length) {\n          // Don't include the function's name if it will be included in the\n          // prefix, or if it's invalid as a name in a function expression.\n          if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {\n            start += prefix.length;\n          }\n\n          return this.getPrefix() + this.fnString.substr(start);\n        }\n      }\n\n      this.pos = start;\n    }\n    /**\n     * Attempt to advance the parser past the keywords expected to be at the\n     * start of this function's definition. This method sets `this.hadKeyword`\n     * based on whether or not a `function` keyword is consumed.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"tryParsePrefixTokens\",\n    value: function tryParsePrefixTokens() {\n      var posPrev = this.pos;\n      this.hadKeyword = false;\n\n      switch (this.fnType) {\n        case \"AsyncFunction\":\n          if (this.consumeSyntax() !== \"async\") return false;\n          posPrev = this.pos;\n        // tslint:disable-next-line no-switch-case-fall-through\n\n        case \"Function\":\n          if (this.consumeSyntax() === \"function\") {\n            this.hadKeyword = true;\n          } else {\n            this.pos = posPrev;\n          }\n\n          return true;\n\n        case \"AsyncGeneratorFunction\":\n          if (this.consumeSyntax() !== \"async\") return false;\n        // tslint:disable-next-line no-switch-case-fall-through\n\n        case \"GeneratorFunction\":\n          var token = this.consumeSyntax();\n\n          if (token === \"function\") {\n            token = this.consumeSyntax();\n            this.hadKeyword = true;\n          }\n\n          return token === \"*\";\n      }\n    }\n    /**\n     * Advance the parser past one element of JavaScript syntax. This could be a\n     * matched pair of delimiters, like braces or parentheses, or an atomic unit\n     * like a keyword, variable, or operator. Return a normalized string\n     * representation of the element parsed--for example, returns '{}' for a\n     * matched pair of braces. Comments and whitespace are skipped.\n     *\n     * (This isn't a full parser, so the token scanning logic used here is as\n     * simple as it can be. As a consequence, some things that are one token in\n     * JavaScript, like decimal number literals or most multicharacter operators\n     * like '&&', are split into more than one token here. However, awareness of\n     * some multicharacter sequences like '=>' is necessary, so we match the few\n     * of them that we care about.)\n     */\n\n  }, {\n    key: \"consumeSyntax\",\n    value: function consumeSyntax(wordLikeToken) {\n      var m = this.consumeMatch(/^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/);\n      if (!m) return;\n\n      var _m2 = _slicedToArray(m, 2),\n          token = _m2[0],\n          match = _m2[1];\n\n      this.consumeWhitespace();\n      if (match) return wordLikeToken || match;\n\n      switch (token) {\n        case \"(\":\n          return this.consumeSyntaxUntil(\"(\", \")\");\n\n        case \"[\":\n          return this.consumeSyntaxUntil(\"[\", \"]\");\n\n        case \"{\":\n          return this.consumeSyntaxUntil(\"{\", \"}\");\n\n        case \"`\":\n          return this.consumeTemplate();\n\n        case '\"':\n          return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n\n        case \"'\":\n          return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n      }\n\n      return token;\n    }\n  }, {\n    key: \"consumeSyntaxUntil\",\n    value: function consumeSyntaxUntil(startToken, endToken) {\n      var isRegExpAllowed = true;\n\n      for (;;) {\n        var token = this.consumeSyntax();\n        if (token === endToken) return startToken + endToken;\n        if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n        if (token === \"/\" && isRegExpAllowed && this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)) {\n          isRegExpAllowed = false;\n          this.consumeWhitespace();\n        } else {\n          isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n        }\n      }\n    }\n  }, {\n    key: \"consumeMatch\",\n    value: function consumeMatch(re) {\n      var m = re.exec(this.fnString.substr(this.pos));\n      if (m) this.pos += m[0].length;\n      return m;\n    }\n    /**\n     * Advance the parser past an arbitrary regular expression. Return `token`,\n     * or the match object of the regexp.\n     */\n\n  }, {\n    key: \"consumeRegExp\",\n    value: function consumeRegExp(re, token) {\n      var m = re.exec(this.fnString.substr(this.pos));\n      if (!m) return;\n      this.pos += m[0].length;\n      this.consumeWhitespace();\n      return token;\n    }\n    /**\n     * Advance the parser past a template string.\n     */\n\n  }, {\n    key: \"consumeTemplate\",\n    value: function consumeTemplate() {\n      for (;;) {\n        this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n        if (this.fnString[this.pos] === \"`\") {\n          this.pos++;\n          this.consumeWhitespace();\n          return \"`\";\n        }\n\n        if (this.fnString.substr(this.pos, 2) === \"${\") {\n          this.pos += 2;\n          this.consumeWhitespace();\n          if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n        }\n\n        return;\n      }\n    }\n    /**\n     * Advance the parser past any whitespace or comments.\n     */\n\n  }, {\n    key: \"consumeWhitespace\",\n    value: function consumeWhitespace() {\n      this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n    }\n  }]);\n\n  return FunctionParser;\n}();\n\nexports.FunctionParser = FunctionParser;","map":null,"metadata":{},"sourceType":"script"}