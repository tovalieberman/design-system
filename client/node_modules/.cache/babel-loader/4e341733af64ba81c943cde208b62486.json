{"ast":null,"code":"var hasInherit = require('./has-inherit');\n\nvar everyValuesPair = require('./every-values-pair');\n\nvar findComponentIn = require('./find-component-in');\n\nvar isComponentOf = require('./is-component-of');\n\nvar isMergeableShorthand = require('./is-mergeable-shorthand');\n\nvar overridesNonComponentShorthand = require('./overrides-non-component-shorthand');\n\nvar sameVendorPrefixesIn = require('./vendor-prefixes').same;\n\nvar compactable = require('../compactable');\n\nvar deepClone = require('../clone').deep;\n\nvar restoreWithComponents = require('../restore-with-components');\n\nvar shallowClone = require('../clone').shallow;\n\nvar restoreFromOptimizing = require('../../restore-from-optimizing');\n\nvar Token = require('../../../tokenizer/token');\n\nvar Marker = require('../../../tokenizer/marker');\n\nvar serializeProperty = require('../../../writer/one-time').property;\n\nfunction wouldBreakCompatibility(property, validator) {\n  for (var i = 0; i < property.components.length; i++) {\n    var component = property.components[i];\n    var descriptor = compactable[component.name];\n    var canOverride = descriptor && descriptor.canOverride || canOverride.sameValue;\n\n    var _component = shallowClone(component);\n\n    _component.value = [[Token.PROPERTY_VALUE, descriptor.defaultValue]];\n\n    if (!everyValuesPair(canOverride.bind(null, validator), _component, component)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction overrideIntoMultiplex(property, by) {\n  by.unused = true;\n  turnIntoMultiplex(by, multiplexSize(property));\n  property.value = by.value;\n}\n\nfunction overrideByMultiplex(property, by) {\n  by.unused = true;\n  property.multiplex = true;\n  property.value = by.value;\n}\n\nfunction overrideSimple(property, by) {\n  by.unused = true;\n  property.value = by.value;\n}\n\nfunction override(property, by) {\n  if (by.multiplex) overrideByMultiplex(property, by);else if (property.multiplex) overrideIntoMultiplex(property, by);else overrideSimple(property, by);\n}\n\nfunction overrideShorthand(property, by) {\n  by.unused = true;\n\n  for (var i = 0, l = property.components.length; i < l; i++) {\n    override(property.components[i], by.components[i], property.multiplex);\n  }\n}\n\nfunction turnIntoMultiplex(property, size) {\n  property.multiplex = true;\n\n  if (compactable[property.name].shorthand) {\n    turnShorthandValueIntoMultiplex(property, size);\n  } else {\n    turnLonghandValueIntoMultiplex(property, size);\n  }\n}\n\nfunction turnShorthandValueIntoMultiplex(property, size) {\n  var component;\n  var i, l;\n\n  for (i = 0, l = property.components.length; i < l; i++) {\n    component = property.components[i];\n\n    if (!component.multiplex) {\n      turnLonghandValueIntoMultiplex(component, size);\n    }\n  }\n}\n\nfunction turnLonghandValueIntoMultiplex(property, size) {\n  var descriptor = compactable[property.name];\n  var withRealValue = descriptor.intoMultiplexMode == 'real';\n  var withValue = descriptor.intoMultiplexMode == 'real' ? property.value.slice(0) : descriptor.intoMultiplexMode == 'placeholder' ? descriptor.placeholderValue : descriptor.defaultValue;\n  var i = multiplexSize(property);\n  var j;\n  var m = withValue.length;\n\n  for (; i < size; i++) {\n    property.value.push([Token.PROPERTY_VALUE, Marker.COMMA]);\n\n    if (Array.isArray(withValue)) {\n      for (j = 0; j < m; j++) {\n        property.value.push(withRealValue ? withValue[j] : [Token.PROPERTY_VALUE, withValue[j]]);\n      }\n    } else {\n      property.value.push(withRealValue ? withValue : [Token.PROPERTY_VALUE, withValue]);\n    }\n  }\n}\n\nfunction multiplexSize(component) {\n  var size = 0;\n\n  for (var i = 0, l = component.value.length; i < l; i++) {\n    if (component.value[i][1] == Marker.COMMA) size++;\n  }\n\n  return size + 1;\n}\n\nfunction lengthOf(property) {\n  var fakeAsArray = [Token.PROPERTY, [Token.PROPERTY_NAME, property.name]].concat(property.value);\n  return serializeProperty([fakeAsArray], 0).length;\n}\n\nfunction moreSameShorthands(properties, startAt, name) {\n  // Since we run the main loop in `compactOverrides` backwards, at this point some\n  // properties may not be marked as unused.\n  // We should consider reverting the order if possible\n  var count = 0;\n\n  for (var i = startAt; i >= 0; i--) {\n    if (properties[i].name == name && !properties[i].unused) count++;\n    if (count > 1) break;\n  }\n\n  return count > 1;\n}\n\nfunction overridingFunction(shorthand, validator) {\n  for (var i = 0, l = shorthand.components.length; i < l; i++) {\n    if (!anyValue(validator.isUrl, shorthand.components[i]) && anyValue(validator.isFunction, shorthand.components[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction anyValue(fn, property) {\n  for (var i = 0, l = property.value.length; i < l; i++) {\n    if (property.value[i][1] == Marker.COMMA) continue;\n    if (fn(property.value[i][1])) return true;\n  }\n\n  return false;\n}\n\nfunction wouldResultInLongerValue(left, right) {\n  if (!left.multiplex && !right.multiplex || left.multiplex && right.multiplex) return false;\n  var multiplex = left.multiplex ? left : right;\n  var simple = left.multiplex ? right : left;\n  var component;\n  var multiplexClone = deepClone(multiplex);\n  restoreFromOptimizing([multiplexClone], restoreWithComponents);\n  var simpleClone = deepClone(simple);\n  restoreFromOptimizing([simpleClone], restoreWithComponents);\n  var lengthBefore = lengthOf(multiplexClone) + 1 + lengthOf(simpleClone);\n\n  if (left.multiplex) {\n    component = findComponentIn(multiplexClone, simpleClone);\n    overrideIntoMultiplex(component, simpleClone);\n  } else {\n    component = findComponentIn(simpleClone, multiplexClone);\n    turnIntoMultiplex(simpleClone, multiplexSize(multiplexClone));\n    overrideByMultiplex(component, multiplexClone);\n  }\n\n  restoreFromOptimizing([simpleClone], restoreWithComponents);\n  var lengthAfter = lengthOf(simpleClone);\n  return lengthBefore <= lengthAfter;\n}\n\nfunction isCompactable(property) {\n  return property.name in compactable;\n}\n\nfunction noneOverrideHack(left, right) {\n  return !left.multiplex && (left.name == 'background' || left.name == 'background-image') && right.multiplex && (right.name == 'background' || right.name == 'background-image') && anyLayerIsNone(right.value);\n}\n\nfunction anyLayerIsNone(values) {\n  var layers = intoLayers(values);\n\n  for (var i = 0, l = layers.length; i < l; i++) {\n    if (layers[i].length == 1 && layers[i][0][1] == 'none') return true;\n  }\n\n  return false;\n}\n\nfunction intoLayers(values) {\n  var layers = [];\n\n  for (var i = 0, layer = [], l = values.length; i < l; i++) {\n    var value = values[i];\n\n    if (value[1] == Marker.COMMA) {\n      layers.push(layer);\n      layer = [];\n    } else {\n      layer.push(value);\n    }\n  }\n\n  layers.push(layer);\n  return layers;\n}\n\nfunction overrideProperties(properties, withMerging, compatibility, validator) {\n  var mayOverride, right, left, component;\n  var overriddenComponents;\n  var overriddenComponent;\n  var overridingComponent;\n  var overridable;\n  var i, j, k;\n\n  propertyLoop: for (i = properties.length - 1; i >= 0; i--) {\n    right = properties[i];\n    if (!isCompactable(right)) continue;\n    if (right.block) continue;\n    mayOverride = compactable[right.name].canOverride;\n\n    traverseLoop: for (j = i - 1; j >= 0; j--) {\n      left = properties[j];\n      if (!isCompactable(left)) continue;\n      if (left.block) continue;\n      if (left.unused || right.unused) continue;\n      if (left.hack && !right.hack && !right.important || !left.hack && !left.important && right.hack) continue;\n      if (left.important == right.important && left.hack[0] != right.hack[0]) continue;\n      if (left.important == right.important && (left.hack[0] != right.hack[0] || left.hack[1] && left.hack[1] != right.hack[1])) continue;\n      if (hasInherit(right)) continue;\n      if (noneOverrideHack(left, right)) continue;\n\n      if (right.shorthand && isComponentOf(right, left)) {\n        // maybe `left` can be overridden by `right` which is a shorthand?\n        if (!right.important && left.important) continue;\n        if (!sameVendorPrefixesIn([left], right.components)) continue;\n        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) continue;\n\n        if (!isMergeableShorthand(right)) {\n          left.unused = true;\n          continue;\n        }\n\n        component = findComponentIn(right, left);\n        mayOverride = compactable[left.name].canOverride;\n\n        if (everyValuesPair(mayOverride.bind(null, validator), left, component)) {\n          left.unused = true;\n        }\n      } else if (right.shorthand && overridesNonComponentShorthand(right, left)) {\n        // `right` is a shorthand while `left` can be overriden by it, think `border` and `border-top`\n        if (!right.important && left.important) {\n          continue;\n        }\n\n        if (!sameVendorPrefixesIn([left], right.components)) {\n          continue;\n        }\n\n        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) {\n          continue;\n        }\n\n        overriddenComponents = left.shorthand ? left.components : [left];\n\n        for (k = overriddenComponents.length - 1; k >= 0; k--) {\n          overriddenComponent = overriddenComponents[k];\n          overridingComponent = findComponentIn(right, overriddenComponent);\n          mayOverride = compactable[overriddenComponent.name].canOverride;\n\n          if (!everyValuesPair(mayOverride.bind(null, validator), left, overridingComponent)) {\n            continue traverseLoop;\n          }\n        }\n\n        left.unused = true;\n      } else if (withMerging && left.shorthand && !right.shorthand && isComponentOf(left, right, true)) {\n        // maybe `right` can be pulled into `left` which is a shorthand?\n        if (right.important && !left.important) continue;\n\n        if (!right.important && left.important) {\n          right.unused = true;\n          continue;\n        } // Pending more clever algorithm in #527\n\n\n        if (moreSameShorthands(properties, i - 1, left.name)) continue;\n        if (overridingFunction(left, validator)) continue;\n        if (!isMergeableShorthand(left)) continue;\n        component = findComponentIn(left, right);\n\n        if (everyValuesPair(mayOverride.bind(null, validator), component, right)) {\n          var disabledBackgroundMerging = !compatibility.properties.backgroundClipMerging && component.name.indexOf('background-clip') > -1 || !compatibility.properties.backgroundOriginMerging && component.name.indexOf('background-origin') > -1 || !compatibility.properties.backgroundSizeMerging && component.name.indexOf('background-size') > -1;\n          var nonMergeableValue = compactable[right.name].nonMergeableValue === right.value[0][1];\n          if (disabledBackgroundMerging || nonMergeableValue) continue;\n          if (!compatibility.properties.merging && wouldBreakCompatibility(left, validator)) continue;\n          if (component.value[0][1] != right.value[0][1] && (hasInherit(left) || hasInherit(right))) continue;\n          if (wouldResultInLongerValue(left, right)) continue;\n          if (!left.multiplex && right.multiplex) turnIntoMultiplex(left, multiplexSize(right));\n          override(component, right);\n          left.dirty = true;\n        }\n      } else if (withMerging && left.shorthand && right.shorthand && left.name == right.name) {\n        // merge if all components can be merged\n        if (!left.multiplex && right.multiplex) continue;\n\n        if (!right.important && left.important) {\n          right.unused = true;\n          continue propertyLoop;\n        }\n\n        if (right.important && !left.important) {\n          left.unused = true;\n          continue;\n        }\n\n        if (!isMergeableShorthand(right)) {\n          left.unused = true;\n          continue;\n        }\n\n        for (k = left.components.length - 1; k >= 0; k--) {\n          var leftComponent = left.components[k];\n          var rightComponent = right.components[k];\n          mayOverride = compactable[leftComponent.name].canOverride;\n          if (!everyValuesPair(mayOverride.bind(null, validator), leftComponent, rightComponent)) continue propertyLoop;\n        }\n\n        overrideShorthand(left, right);\n        left.dirty = true;\n      } else if (withMerging && left.shorthand && right.shorthand && isComponentOf(left, right)) {\n        // border is a shorthand but any of its components is a shorthand too\n        if (!left.important && right.important) continue;\n        component = findComponentIn(left, right);\n        mayOverride = compactable[right.name].canOverride;\n        if (!everyValuesPair(mayOverride.bind(null, validator), component, right)) continue;\n\n        if (left.important && !right.important) {\n          right.unused = true;\n          continue;\n        }\n\n        var rightRestored = compactable[right.name].restore(right, compactable);\n        if (rightRestored.length > 1) continue;\n        component = findComponentIn(left, right);\n        override(component, right);\n        right.dirty = true;\n      } else if (left.name == right.name) {\n        // two non-shorthands should be merged based on understandability\n        overridable = true;\n\n        if (right.shorthand) {\n          for (k = right.components.length - 1; k >= 0 && overridable; k--) {\n            overriddenComponent = left.components[k];\n            overridingComponent = right.components[k];\n            mayOverride = compactable[overridingComponent.name].canOverride;\n            overridable = overridable && everyValuesPair(mayOverride.bind(null, validator), overriddenComponent, overridingComponent);\n          }\n        } else {\n          mayOverride = compactable[right.name].canOverride;\n          overridable = everyValuesPair(mayOverride.bind(null, validator), left, right);\n        }\n\n        if (left.important && !right.important && overridable) {\n          right.unused = true;\n          continue;\n        }\n\n        if (!left.important && right.important && overridable) {\n          left.unused = true;\n          continue;\n        }\n\n        if (!overridable) {\n          continue;\n        }\n\n        left.unused = true;\n      }\n    }\n  }\n}\n\nmodule.exports = overrideProperties;","map":null,"metadata":{},"sourceType":"script"}