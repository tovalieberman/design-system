{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/tliebe1/Code/design-system/glic-design-system/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar EE = require('events');\n\nvar Yallist = require('yallist');\n\nvar EOF = Symbol('EOF');\nvar MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nvar EMITTED_END = Symbol('emittedEnd');\nvar CLOSED = Symbol('closed');\nvar READ = Symbol('read');\nvar FLUSH = Symbol('flush');\nvar doIter = process.env._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nvar ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nvar ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');\nvar FLUSHCHUNK = Symbol('flushChunk');\n\nvar SD = require('string_decoder').StringDecoder;\n\nvar ENCODING = Symbol('encoding');\nvar DECODER = Symbol('decoder');\nvar FLOWING = Symbol('flowing');\nvar RESUME = Symbol('resume');\nvar BUFFERLENGTH = Symbol('bufferLength');\nvar BUFFERPUSH = Symbol('bufferPush');\nvar BUFFERSHIFT = Symbol('bufferShift');\nvar OBJECTMODE = Symbol('objectMode'); // Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\n\nvar B = Buffer;\n/* istanbul ignore next */\n\nif (!B.alloc) {\n  B = require('safe-buffer').Buffer;\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction (_EE) {\n  _inherits(MiniPass, _EE);\n\n  function MiniPass(options) {\n    var _this;\n\n    _classCallCheck(this, MiniPass);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MiniPass).call(this));\n    _this[FLOWING] = false;\n    _this.pipes = new Yallist();\n    _this.buffer = new Yallist();\n    _this[OBJECTMODE] = options && options.objectMode || false;\n    if (_this[OBJECTMODE]) _this[ENCODING] = null;else _this[ENCODING] = options && options.encoding || null;\n    if (_this[ENCODING] === 'buffer') _this[ENCODING] = null;\n    _this[DECODER] = _this[ENCODING] ? new SD(_this[ENCODING]) : null;\n    _this[EOF] = false;\n    _this[EMITTED_END] = false;\n    _this[CLOSED] = false;\n    _this.writable = true;\n    _this.readable = true;\n    _this[BUFFERLENGTH] = 0;\n    return _this;\n  }\n\n  _createClass(MiniPass, [{\n    key: \"setEncoding\",\n    value: function setEncoding(enc) {\n      this.encoding = enc;\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      if (this[EOF]) throw new Error('write after end');\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (!encoding) encoding = 'utf8'; // fast-path writing strings of same encoding to a stream with\n      // an empty buffer, skipping the buffer/decoder dance\n\n      if (typeof chunk === 'string' && !this[OBJECTMODE] && // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n        chunk = B.from(chunk, encoding);\n      }\n\n      if (B.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n      try {\n        return this.flowing ? (this.emit('data', chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);\n      } finally {\n        this.emit('readable');\n        if (cb) cb();\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function read(n) {\n      try {\n        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;\n        if (this[OBJECTMODE]) n = null;\n\n        if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n          if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([B.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);\n        }\n\n        return this[READ](n || null, this.buffer.head.value);\n      } finally {\n        this[MAYBE_EMIT_END]();\n      }\n    }\n  }, {\n    key: READ,\n    value: function value(n, chunk) {\n      if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n        this.buffer.head.value = chunk.slice(n);\n        chunk = chunk.slice(0, n);\n        this[BUFFERLENGTH] -= n;\n      }\n      this.emit('data', chunk);\n      if (!this.buffer.length && !this[EOF]) this.emit('drain');\n      return chunk;\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (typeof chunk === 'function') cb = chunk, chunk = null;\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (chunk) this.write(chunk, encoding);\n      if (cb) this.once('end', cb);\n      this[EOF] = true;\n      this.writable = false;\n      if (this.flowing) this[MAYBE_EMIT_END]();\n    } // don't let the internal resume be overwritten\n\n  }, {\n    key: RESUME,\n    value: function value() {\n      this[FLOWING] = true;\n      this.emit('resume');\n      if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      return this[RESUME]();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this[FLOWING] = false;\n    }\n  }, {\n    key: BUFFERPUSH,\n    value: function value(chunk) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n      return this.buffer.push(chunk);\n    }\n  }, {\n    key: BUFFERSHIFT,\n    value: function value() {\n      if (this.buffer.length) {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;\n      }\n\n      return this.buffer.shift();\n    }\n  }, {\n    key: FLUSH,\n    value: function value() {\n      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n      if (!this.buffer.length && !this[EOF]) this.emit('drain');\n    }\n  }, {\n    key: FLUSHCHUNK,\n    value: function value(chunk) {\n      return chunk ? (this.emit('data', chunk), this.flowing) : false;\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(dest, opts) {\n      var _this2 = this;\n\n      if (dest === process.stdout || dest === process.stderr) (opts = opts || {}).end = false;\n      var p = {\n        dest: dest,\n        opts: opts,\n        ondrain: function ondrain(_) {\n          return _this2[RESUME]();\n        }\n      };\n      this.pipes.push(p);\n      dest.on('drain', p.ondrain);\n      this[RESUME]();\n      return dest;\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(ev, fn) {\n      return this.on(ev, fn);\n    }\n  }, {\n    key: \"on\",\n    value: function on(ev, fn) {\n      try {\n        return _get(_getPrototypeOf(MiniPass.prototype), \"on\", this).call(this, ev, fn);\n      } finally {\n        if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (ev === 'end' && this[EMITTED_END]) {\n          _get(_getPrototypeOf(MiniPass.prototype), \"emit\", this).call(this, 'end');\n\n          this.removeAllListeners('end');\n        }\n      }\n    }\n  }, {\n    key: MAYBE_EMIT_END,\n    value: function value() {\n      if (!this[EMITTED_END] && this.buffer.length === 0 && this[EOF]) {\n        this.emit('end');\n        this.emit('prefinish');\n        this.emit('finish');\n        if (this[CLOSED]) this.emit('close');\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      var _this3 = this;\n\n      if (ev === 'data') {\n        if (!data) return;\n        if (this.pipes.length) this.pipes.forEach(function (p) {\n          return p.dest.write(data) || _this3.pause();\n        });\n      } else if (ev === 'end') {\n        if (this[EMITTED_END] === true) return;\n        this[EMITTED_END] = true;\n        this.readable = false;\n\n        if (this[DECODER]) {\n          data = this[DECODER].end();\n\n          if (data) {\n            this.pipes.forEach(function (p) {\n              return p.dest.write(data);\n            });\n\n            _get(_getPrototypeOf(MiniPass.prototype), \"emit\", this).call(this, 'data', data);\n          }\n        }\n\n        this.pipes.forEach(function (p) {\n          p.dest.removeListener('drain', p.ondrain);\n          if (!p.opts || p.opts.end !== false) p.dest.end();\n        });\n      } else if (ev === 'close') {\n        this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n        if (!this[EMITTED_END]) return;\n      }\n\n      var args = new Array(arguments.length);\n      args[0] = ev;\n      args[1] = data;\n\n      if (arguments.length > 2) {\n        for (var i = 2; i < arguments.length; i++) {\n          args[i] = arguments[i];\n        }\n      }\n\n      try {\n        return _get(_getPrototypeOf(MiniPass.prototype), \"emit\", this).apply(this, args);\n      } finally {\n        if (ev !== 'end') this[MAYBE_EMIT_END]();else this.removeAllListeners('end');\n      }\n    } // const all = await stream.collect()\n\n  }, {\n    key: \"collect\",\n    value: function collect() {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        var buf = [];\n\n        _this4.on('data', function (c) {\n          return buf.push(c);\n        });\n\n        _this4.on('end', function () {\n          return resolve(buf);\n        });\n\n        _this4.on('error', reject);\n      });\n    } // for await (let chunk of stream)\n\n  }, {\n    key: ASYNCITERATOR,\n    value: function value() {\n      var _this5 = this;\n\n      var next = function next() {\n        var res = _this5.read();\n\n        if (res !== null) return Promise.resolve({\n          done: false,\n          value: res\n        });\n        if (_this5[EOF]) return Promise.resolve({\n          done: true\n        });\n        var resolve = null;\n        var reject = null;\n\n        var onerr = function onerr(er) {\n          _this5.removeListener('data', ondata);\n\n          _this5.removeListener('end', onend);\n\n          reject(er);\n        };\n\n        var ondata = function ondata(value) {\n          _this5.removeListener('error', onerr);\n\n          _this5.removeListener('end', onend);\n\n          _this5.pause();\n\n          resolve({\n            value: value,\n            done: !!_this5[EOF]\n          });\n        };\n\n        var onend = function onend() {\n          _this5.removeListener('error', onerr);\n\n          _this5.removeListener('data', ondata);\n\n          resolve({\n            done: true\n          });\n        };\n\n        return new Promise(function (res, rej) {\n          reject = rej;\n          resolve = res;\n\n          _this5.once('error', onerr);\n\n          _this5.once('end', onend);\n\n          _this5.once('data', ondata);\n        });\n      };\n\n      return {\n        next: next\n      };\n    } // for (let chunk of stream)\n\n  }, {\n    key: ITERATOR,\n    value: function value() {\n      var _this6 = this;\n\n      var next = function next() {\n        var value = _this6.read();\n\n        var done = value === null;\n        return {\n          value: value,\n          done: done\n        };\n      };\n\n      return {\n        next: next\n      };\n    }\n  }, {\n    key: \"bufferLength\",\n    get: function get() {\n      return this[BUFFERLENGTH];\n    }\n  }, {\n    key: \"encoding\",\n    get: function get() {\n      return this[ENCODING];\n    },\n    set: function set(enc) {\n      var _this7 = this;\n\n      if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n      if (this[ENCODING] !== enc) {\n        this[DECODER] = enc ? new SD(enc) : null;\n        if (this.buffer.length) this.buffer = this.buffer.map(function (chunk) {\n          return _this7[DECODER].write(chunk);\n        });\n      }\n\n      this[ENCODING] = enc;\n    }\n  }, {\n    key: \"flowing\",\n    get: function get() {\n      return this[FLOWING];\n    }\n  }, {\n    key: \"emittedEnd\",\n    get: function get() {\n      return this[EMITTED_END];\n    }\n  }]);\n\n  return MiniPass;\n}(EE);","map":null,"metadata":{},"sourceType":"script"}